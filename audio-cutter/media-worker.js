var Module = void 0 !== Module ? Module : {}; const extMapping = { mp3: "mp3", aac: "m4a", flac: "flac", pcm: "wav" }, codecsMapping = { m4a: ["-c:a", "aac", "-f", "adts"], m4r: ["-c:a", "aac", "-f", "adts"], flac: ["-c:a", "flac", "-f", "flac"], mp3: ["-c:a", "mp3", "-f", "mp3"], wav: ["-c:a", "pcm_s16le"] }, formatsMapping = { m4a: "adts", m4r: "adts", flac: "flac", mp3: "mp3", wav: "s16le" }, validBitrates = [32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 256, 320]; Module.bitrate = 320, Module.autoExt = extMapping.mp3, Module.extOrigin = "unsupported", Module.progressScaleFactor = 100, Module.progressOffset = 0, Module.partTime = 3, Module.partExt = "mp4", Module.preventCopyCoverCodec = !1, Module.copyCoverCodec = !1; const TASKS = { DECODE: 1, CUT: 2, CHECK_IF_AUDIO_AND_MP3: 3, GET_WAVEFORM: 4, GET_FILE_PARTS: 5 }, MP3_PREVIEW = "/work/preview.mp3", MP3_WAVEFORM = "/work/waveform.png", M4R_MAX_TIME = 40; Module.outFileName = "/work/converted", Module.print = Module.printErr = msg => { }; const checkBitrate = (data = "") => { let matches; (matches = data.match(/stream.*audio:.*\d{1,}\s{1}kb\/s/)) && (Module.bitrate = getClosestValidBitrate(parseFloat(matches[0].match(/\d{1,}\s{1}kb\/s/)) || Module.bitrate)) }, getClosestValidBitrate = bitrate => { let closest = void 0; for (let i = 0; i < validBitrates.length; i++)(null == closest || Math.abs(bitrate - closest) > Math.abs(validBitrates[i] - bitrate)) && (closest = validBitrates[i]); return closest }, checkProgress = (data = "") => { if (Module.activeTask == TASKS.GET_FILE_PARTS) { let matches = data.match(/work\/part\d{1,}/); if (matches && (Module.partIndex = parseFloat(matches[0].replace(/\D/g, "")) - 1, Module.partIndex >= 0)) { const fileData = FS.readFile(`/work/part${Module.partIndex}.${Module.partExt}`); self.postMessage({ type: "filePart", index: Module.partIndex, part: fileData.buffer, defaultPartTime: Module.partTime }, [fileData.buffer]), FS.unlink(`/work/part${Module.partIndex}.${Module.partExt}`) } return } if (!Module.fileDuration) return; let matches; if (matches = data.match(/time=\d+:\d+:\d+\.\d+/)) { let digits = matches[0].match(/\d{1,}/g); digits && 4 == digits.length && self.postMessage({ type: Module.activeTask == TASKS.DECODE ? "decodeProgress" : Module.activeTask == TASKS.GET_WAVEFORM ? "waveformProgress" : "encodeProgress", progress: Math.ceil(1e3 * parseFloat(60 * parseFloat(digits[0]) * 60 + parseFloat(60 * digits[1]) + parseFloat(digits[2]) + "." + parseFloat(digits[3])) / Module.fileDuration * Module.progressScaleFactor + Module.progressOffset) }) } }, checkFileDuration = (data = "") => { let matches; if (matches = data.match(/duration:\s*\d+:\d+:\d+\.\d+/)) { let digits = matches[0].match(/\d{1,}/g); digits && 4 == digits.length && (Module.fileDuration = Math.ceil(1e3 * parseFloat(60 * parseFloat(digits[0]) * 60 + parseFloat(60 * digits[1]) + parseFloat(digits[2]) + "." + parseFloat(digits[3])))) } else Module.fileDuration || (Module.fileDuration = 18e5) }, checkIfAudioAndMp3 = (data = "") => { /stream.*audio:/.test(data) && (Module.isAudio = !0), /(invalid\s{1,}(spng|jpeg|jpg)\s{1}signature)|(unspecified\s{1,}size)/i.test(data) && (Module.preventCopyCoverCodec = !0, Module.copyCoverCodec = !1), /stream.*video:.*(jpeg|jpg|png)/.test(data) && !Module.preventCopyCoverCodec && (Module.copyCoverCodec = !0), /stream.*audio:.*mp3/.test(data) ? (Module.isMp3 = !0, Module.autoExt = Module.extOrigin = extMapping.mp3) : /stream.*audio:.*aac/.test(data) ? Module.autoExt = Module.extOrigin = extMapping.aac : /stream.*audio:.*flac/.test(data) ? Module.autoExt = Module.extOrigin = extMapping.flac : /stream.*audio:.*vorbis/.test(data) ? (Module.autoExt = "mp3", Module.extOrigin = "webm") : /stream.*audio:.*opus/.test(data) ? (Module.autoExt = "mp3", Module.extOrigin = "webm") : /stream.*audio:.*pcm/.test(data) && (Module.autoExt = "wav", Module.extOrigin = "wav") }, checkIfDRMProtected = (data = "") => { /stream.*(audio|video):.*(.*drm.*)/.test(data) && (self.postMessage({ type: "drmError" }), self.close()) }, checkOutFileNotSpecifiedError = data => { /file must be specified/.test(data) && (Module.outFileNotSpecifiedError = !0) }, outHandler = data => { if (data = data.toString().toLowerCase(), Module.activeTask == TASKS.CHECK_IF_AUDIO_AND_MP3) return checkFileDuration(data), checkOutFileNotSpecifiedError(data), checkBitrate(data), checkIfDRMProtected(data), checkIfAudioAndMp3(data); Module.activeTask == TASKS.GET_WAVEFORM && (checkFileDuration(data), checkBitrate(data)), Module.activeTask != TASKS.CUT && checkFileDuration(data), checkProgress(data) }, stdErrorHandler = outHandler, stdOutHandler = outHandler; Module.decodeFile = (fileName, waveformParams, copyCodec) => { Module.activeTask = TASKS.DECODE, copyCodec ? Module.callMain(["-hide_banner", "-i", fileName, "-c:a", "copy", ...Module.copyCoverCodec ? ["-c:v", "copy"] : ["-vn"], MP3_PREVIEW]) : Module.callMain(["-hide_banner", "-i", fileName, "-filter_complex", `[0:a:0]compand,aformat=channel_layouts=mono,showwavespic=s=${waveformParams.width}x${waveformParams.height}:split_channels=0:colors=#00ff8d@1.0:scale=lin[waveform]`, "-vframes", "1", "-map", "[waveform]", MP3_WAVEFORM, "-map", "0:a:0", ...codecsMapping.mp3, ...Module.copyCoverCodec ? ["-c:v", "copy"] : ["-vn"], "-b:a", `${Module.bitrate}k`, MP3_PREVIEW]) }, Module.cutFile = (fileName, params) => { Module.activeTask = TASKS.CUT; const copyCodec = params.copyCodec; Module.outFileName += `.${params.format}`; let duration = params.time.saveTo - params.time.saveFrom; if (parseInt(Module.bitrate) || (Module.bitrate = 320), "m4r" == params.format.toLowerCase() && (duration = Math.min(40, duration), Module.bitrate = Math.min(Module.bitrate, 256)), Module.fileDuration = 1e3 * duration, copyCodec) Module.callMain(["-hide_banner", "-ss", params.time.saveFrom.toString(), "-t", duration.toString(), "-i", fileName, "-c:a", "copy", ...Module.copyCoverCodec ? ["-c:v", "copy"] : ["-vn"], "-f", formatsMapping[params.format], Module.outFileName]); else { const command = ["-hide_banner", "-ss", params.time.saveFrom.toString(), "-t", duration.toString(), "-i", fileName, ...codecsMapping[params.format], ...Module.copyCoverCodec ? ["-c:v", "copy"] : ["-vn"]]; params.fadeIn && params.fadeOut ? command.push("-af", `afade=t=in:st=0:d=${params.fadeDuration},afade=t=out:st=${Math.max(0, duration - params.fadeDuration)}:d=${params.fadeDuration}`) : params.fadeIn ? command.push("-af", `afade=t=in:st=0:d=${params.fadeDuration}`) : params.fadeOut && command.push("-af", `afade=t=out:st=${Math.max(0, duration - params.fadeDuration)}:d=${params.fadeDuration}`), command.push("-b:a", `${Module.bitrate}k`), "m4r" != params.format.toLowerCase() && "m4a" != params.format.toLowerCase() || command.push("-f", "ipod"), command.push(Module.outFileName), Module.callMain(command) } }, Module.getFileParts = fileName => { Module.activeTask = TASKS.GET_FILE_PARTS, Module.callMain(["-hide_banner", "-i", fileName, "-map", "0:a:0", "-c:a", "copy", "-map_metadata", "-1", "-f", "segment", "-segment_time", `${Module.partTime}`, "-reset_timestamps", "1", `/work/part%d.${Module.partExt}`]) }, Module.checkIfAudioAndMP3 = fileName => { Module.activeTask = TASKS.CHECK_IF_AUDIO_AND_MP3, Module.callMain(["-hide_banner", "-i", fileName]) }; const makeOutHandler = callback => { var buffer = []; return function (character, exit) { if (exit && buffer.length) return callback(UTF8ArrayToString(buffer, 0)); 10 === character || 13 === character ? (callback(UTF8ArrayToString(buffer, 0)), buffer = []) : 0 !== character && buffer.push(character) } }, preRunTask = () => { abort = function (what) { Module.onAbort && Module.onAbort(what), void 0 !== what ? (out(what), err(what), what = JSON.stringify(what)) : what = "", ABORT = !0, EXITSTATUS = 1, self.postMessage({ type: "internalError", error: what }) }, Module.abort = abort, FS.init.initialized || (FS.init(null, makeOutHandler(stdOutHandler), makeOutHandler(stdErrorHandler)), FS.mkdir("/work"), FS.mkdir("/working"), self.postMessage({ type: "ready" })) }, postExitTask = status => { if (clearInterval(Module.progressInterval), Module.activeTask == TASKS.DECODE) { if (0 != status) { try { FS.unlink(MP3_PREVIEW), FS.unlink(MP3_WAVEFORM) } catch (e) { } return self.postMessage({ type: "decodeError" }) } const files = []; let file = FS.findObject(MP3_PREVIEW); file && files.push({ data: FS.readFile(MP3_PREVIEW), type: "mp3" }), file = FS.findObject(MP3_WAVEFORM), file && files.push({ data: FS.readFile(MP3_WAVEFORM), type: "waveform" }), self.postMessage({ type: "decoded", files: files }, files.map(file => file.data.buffer)); try { FS.unlink(MP3_PREVIEW), FS.unlink(MP3_WAVEFORM) } catch (e) { } } else { if (Module.activeTask == TASKS.CHECK_IF_AUDIO_AND_MP3) return status && !Module.outFileNotSpecifiedError ? self.postMessage({ type: "checkedIfAudioAndMp3Error" }) : self.postMessage({ type: "checkedIfAudioAndMp3", result: { mp3: !!Module.isMp3, audio: !!Module.isAudio, autoExt: Module.autoExt, extOrigin: Module.extOrigin, bitrate: Module.bitrate, duration: parseFloat(Module.fileDuration) / 1e3 || 3600, copyCoverCodec: Module.copyCoverCodec } }); if (Module.activeTask == TASKS.GET_FILE_PARTS) { if (0 != status) return self.postMessage({ type: "getFilePartsError" }); Module.partIndex += 1; try { const fileData = FS.readFile(`/work/part${Module.partIndex}.${Module.partExt}`); self.postMessage({ type: "filePart", index: Module.partIndex, part: fileData.buffer, defaultPartTime: Module.partTime, last: !0 }, [fileData.buffer]), FS.unlink(`/work/part${Module.partIndex}.${Module.partExt}`) } catch (err) { return self.postMessage({ type: "decodeError" }) } } else if (Module.activeTask == TASKS.GET_WAVEFORM) { if (FS.findObject(MP3_WAVEFORM)) { const result = { data: FS.readFile(MP3_WAVEFORM) }; self.postMessage({ type: "waveformReady", file: result }, [result.data.buffer]) } } else if (Module.activeTask == TASKS.CUT) { if (0 !== status) return self.postMessage({ type: "fileCutError" }); if (FS.findObject(Module.outFileName)) { const data = FS.readFile(Module.outFileName); self.postMessage({ type: "fileCut", file: data }, [data.buffer]) } } } }; Module.preRun = preRunTask, Module.onExit = postExitTask; var key, moduleOverrides = {}; for (key in Module) Module.hasOwnProperty(key) && (moduleOverrides[key] = Module[key]); Module.arguments = [], Module.thisProgram = "./this.program", Module.quit = function (status, toThrow) { throw toThrow }, Module.preRun = [], Module.postRun = []; var ENVIRONMENT_IS_WEB = !1, ENVIRONMENT_IS_WORKER = !0, scriptDirectory = ""; function locateFile(path) { return Module.locateFile ? Module.locateFile(path, scriptDirectory) : scriptDirectory + path } (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && (ENVIRONMENT_IS_WORKER ? scriptDirectory = self.location.href : document.currentScript && (scriptDirectory = document.currentScript.src), scriptDirectory = 0 !== scriptDirectory.indexOf("blob:") ? scriptDirectory.substr(0, scriptDirectory.lastIndexOf("/") + 1) : "", Module.read = function shell_read(url) { var xhr = new XMLHttpRequest; return xhr.open("GET", url, !1), xhr.send(null), xhr.responseText }, ENVIRONMENT_IS_WORKER && (Module.readBinary = function readBinary(url) { var xhr = new XMLHttpRequest; return xhr.open("GET", url, !1), xhr.responseType = "arraybuffer", xhr.send(null), new Uint8Array(xhr.response) }), Module.readAsync = function readAsync(url, onload, onerror) { var xhr = new XMLHttpRequest; xhr.open("GET", url, !0), xhr.responseType = "arraybuffer", xhr.onload = function xhr_onload() { 200 == xhr.status || 0 == xhr.status && xhr.response ? onload(xhr.response) : onerror() }, xhr.onerror = onerror, xhr.send(null) }, Module.setWindowTitle = function (title) { document.title = title }); var out = Module.print || ("undefined" != typeof console ? console.log.bind(console) : "undefined" != typeof print ? print : null), err = Module.printErr || ("undefined" != typeof printErr ? printErr : "undefined" != typeof console && console.warn.bind(console) || out); for (key in moduleOverrides) moduleOverrides.hasOwnProperty(key) && (Module[key] = moduleOverrides[key]); function dynamicAlloc(size) { var ret = HEAP32[DYNAMICTOP_PTR >> 2], end = ret + size + 15 & -16; if (end <= _emscripten_get_heap_size()) HEAP32[DYNAMICTOP_PTR >> 2] = end; else if (!_emscripten_resize_heap(end)) return 0; return ret } function getNativeTypeSize(type) { switch (type) { case "i1": case "i8": return 1; case "i16": return 2; case "i32": return 4; case "i64": return 8; case "float": return 4; case "double": return 8; default: if ("*" === type[type.length - 1]) return 4; if ("i" === type[0]) { var bits = parseInt(type.substr(1)); return assert(bits % 8 == 0, "getNativeTypeSize invalid bits " + bits + ", type " + type), bits / 8 } return 0 } } moduleOverrides = void 0; var wasmMemory, wasmTable, asm2wasmImports = { "f64-rem": function (x, y) { return x % y }, debugger: function () { } }, functionPointers = new Array(0); "object" != typeof WebAssembly && err("no native wasm support detected"); var ABORT = !1, EXITSTATUS = 0; function assert(condition, text) { condition || abort("Assertion failed: " + text) } function setValue(ptr, value, type, noSafe) { switch ("*" === (type = type || "i8").charAt(type.length - 1) && (type = "i32"), type) { case "i1": case "i8": HEAP8[ptr >> 0] = value; break; case "i16": HEAP16[ptr >> 1] = value; break; case "i32": HEAP32[ptr >> 2] = value; break; case "i64": tempI64 = [value >>> 0, (tempDouble = value, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[ptr >> 2] = tempI64[0], HEAP32[ptr + 4 >> 2] = tempI64[1]; break; case "float": HEAPF32[ptr >> 2] = value; break; case "double": HEAPF64[ptr >> 3] = value; break; default: abort("invalid type for setValue: " + type) } } var ALLOC_NORMAL = 0, ALLOC_NONE = 3; function allocate(slab, types, allocator, ptr) { var zeroinit, size; "number" == typeof slab ? (zeroinit = !0, size = slab) : (zeroinit = !1, size = slab.length); var ret, singleType = "string" == typeof types ? types : null; if (ret = allocator == ALLOC_NONE ? ptr : [_malloc, stackAlloc, dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length)), zeroinit) { var stop; for (ptr = ret, assert(0 == (3 & ret)), stop = ret + (-4 & size); ptr < stop; ptr += 4)HEAP32[ptr >> 2] = 0; for (stop = ret + size; ptr < stop;)HEAP8[ptr++ >> 0] = 0; return ret } if ("i8" === singleType) return slab.subarray || slab.slice ? HEAPU8.set(slab, ret) : HEAPU8.set(new Uint8Array(slab), ret), ret; for (var type, typeSize, previousType, i = 0; i < size;) { var curr = slab[i]; 0 !== (type = singleType || types[i]) ? ("i64" == type && (type = "i32"), setValue(ret + i, curr, type), previousType !== type && (typeSize = getNativeTypeSize(type), previousType = type), i += typeSize) : i++ } return ret } function getMemory(size) { return runtimeInitialized ? _malloc(size) : dynamicAlloc(size) } var UTF8Decoder = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0; function UTF8ArrayToString(u8Array, idx, maxBytesToRead) { for (var endIdx = idx + maxBytesToRead, endPtr = idx; u8Array[endPtr] && !(endPtr >= endIdx);)++endPtr; if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) return UTF8Decoder.decode(u8Array.subarray(idx, endPtr)); for (var str = ""; idx < endPtr;) { var u0 = u8Array[idx++]; if (128 & u0) { var u1 = 63 & u8Array[idx++]; if (192 != (224 & u0)) { var u2 = 63 & u8Array[idx++]; if ((u0 = 224 == (240 & u0) ? (15 & u0) << 12 | u1 << 6 | u2 : (7 & u0) << 18 | u1 << 12 | u2 << 6 | 63 & u8Array[idx++]) < 65536) str += String.fromCharCode(u0); else { var ch = u0 - 65536; str += String.fromCharCode(55296 | ch >> 10, 56320 | 1023 & ch) } } else str += String.fromCharCode((31 & u0) << 6 | u1) } else str += String.fromCharCode(u0) } return str } function UTF8ToString(ptr, maxBytesToRead) { return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "" } function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) { if (!(maxBytesToWrite > 0)) return 0; for (var startIdx = outIdx, endIdx = outIdx + maxBytesToWrite - 1, i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); if (u >= 55296 && u <= 57343) u = 65536 + ((1023 & u) << 10) | 1023 & str.charCodeAt(++i); if (u <= 127) { if (outIdx >= endIdx) break; outU8Array[outIdx++] = u } else if (u <= 2047) { if (outIdx + 1 >= endIdx) break; outU8Array[outIdx++] = 192 | u >> 6, outU8Array[outIdx++] = 128 | 63 & u } else if (u <= 65535) { if (outIdx + 2 >= endIdx) break; outU8Array[outIdx++] = 224 | u >> 12, outU8Array[outIdx++] = 128 | u >> 6 & 63, outU8Array[outIdx++] = 128 | 63 & u } else { if (outIdx + 3 >= endIdx) break; outU8Array[outIdx++] = 240 | u >> 18, outU8Array[outIdx++] = 128 | u >> 12 & 63, outU8Array[outIdx++] = 128 | u >> 6 & 63, outU8Array[outIdx++] = 128 | 63 & u } } return outU8Array[outIdx] = 0, outIdx - startIdx } function stringToUTF8(str, outPtr, maxBytesToWrite) { return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite) } function lengthBytesUTF8(str) { for (var len = 0, i = 0; i < str.length; ++i) { var u = str.charCodeAt(i); u >= 55296 && u <= 57343 && (u = 65536 + ((1023 & u) << 10) | 1023 & str.charCodeAt(++i)), u <= 127 ? ++len : len += u <= 2047 ? 2 : u <= 65535 ? 3 : 4 } return len } var UTF16Decoder = "undefined" != typeof TextDecoder ? new TextDecoder("utf-16le") : void 0; function allocateUTF8(str) { var size = lengthBytesUTF8(str) + 1, ret = _malloc(size); return ret && stringToUTF8Array(str, HEAP8, ret, size), ret } function allocateUTF8OnStack(str) { var size = lengthBytesUTF8(str) + 1, ret = stackAlloc(size); return stringToUTF8Array(str, HEAP8, ret, size), ret } function writeArrayToMemory(array, buffer) { HEAP8.set(array, buffer) } function writeAsciiToMemory(str, buffer, dontAddNull) { for (var i = 0; i < str.length; ++i)HEAP8[buffer++ >> 0] = str.charCodeAt(i); dontAddNull || (HEAP8[buffer >> 0] = 0) } function demangle(func) { return func } function demangleAll(text) { return text.replace(/__Z[\w\d_]+/g, (function (x) { var y = demangle(x); return x === y ? x : y + " [" + x + "]" })) } function jsStackTrace() { var err = new Error; if (!err.stack) { try { throw new Error(0) } catch (e) { err = e } if (!err.stack) return "(no stack trace available)" } return err.stack.toString() } function stackTrace() { var js = jsStackTrace(); return Module.extraStackTrace && (js += "\n" + Module.extraStackTrace()), demangleAll(js) } var buffer, HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64, WASM_PAGE_SIZE = 65536; function alignUp(x, multiple) { return x % multiple > 0 && (x += multiple - x % multiple), x } function updateGlobalBufferViews() { Module.HEAP8 = HEAP8 = new Int8Array(buffer), Module.HEAP16 = HEAP16 = new Int16Array(buffer), Module.HEAP32 = HEAP32 = new Int32Array(buffer), Module.HEAPU8 = HEAPU8 = new Uint8Array(buffer), Module.HEAPU16 = HEAPU16 = new Uint16Array(buffer), Module.HEAPU32 = HEAPU32 = new Uint32Array(buffer), Module.HEAPF32 = HEAPF32 = new Float32Array(buffer), Module.HEAPF64 = HEAPF64 = new Float64Array(buffer) } var DYNAMIC_BASE = 7583696, DYNAMICTOP_PTR = 2340784, TOTAL_STACK = 5242880, INITIAL_TOTAL_MEMORY = Module.TOTAL_MEMORY || 16777216; function callRuntimeCallbacks(callbacks) { for (; callbacks.length > 0;) { var callback = callbacks.shift(); if ("function" != typeof callback) { var func = callback.func; "number" == typeof func ? void 0 === callback.arg ? Module.dynCall_v(func) : Module.dynCall_vi(func, callback.arg) : func(void 0 === callback.arg ? null : callback.arg) } else callback() } } INITIAL_TOTAL_MEMORY < TOTAL_STACK && err("TOTAL_MEMORY should be larger than TOTAL_STACK, was " + INITIAL_TOTAL_MEMORY + "! (TOTAL_STACK=" + TOTAL_STACK + ")"), Module.buffer ? buffer = Module.buffer : "object" == typeof WebAssembly && "function" == typeof WebAssembly.Memory ? (wasmMemory = new WebAssembly.Memory({ initial: INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE }), buffer = wasmMemory.buffer) : buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY), updateGlobalBufferViews(), HEAP32[DYNAMICTOP_PTR >> 2] = DYNAMIC_BASE; var __ATPRERUN__ = [], __ATINIT__ = [], __ATMAIN__ = [], __ATEXIT__ = [], __ATPOSTRUN__ = [], runtimeInitialized = !1, runtimeExited = !1; function preRun() { if (Module.preRun) for ("function" == typeof Module.preRun && (Module.preRun = [Module.preRun]); Module.preRun.length;)addOnPreRun(Module.preRun.shift()); callRuntimeCallbacks(__ATPRERUN__) } function ensureInitRuntime() { runtimeInitialized || (runtimeInitialized = !0, Module.noFSInit || FS.init.initialized || FS.init(), TTY.init(), callRuntimeCallbacks(__ATINIT__)) } function preMain() { FS.ignorePermissions = !1, callRuntimeCallbacks(__ATMAIN__) } function exitRuntime() { callRuntimeCallbacks(__ATEXIT__), FS.quit(), TTY.shutdown(), runtimeExited = !0 } function postRun() { if (Module.postRun) for ("function" == typeof Module.postRun && (Module.postRun = [Module.postRun]); Module.postRun.length;)addOnPostRun(Module.postRun.shift()); callRuntimeCallbacks(__ATPOSTRUN__) } function addOnPreRun(cb) { __ATPRERUN__.unshift(cb) } function addOnPostRun(cb) { __ATPOSTRUN__.unshift(cb) } var Math_abs = Math.abs, Math_cos = Math.cos, Math_sin = Math.sin, Math_ceil = Math.ceil, Math_floor = Math.floor, Math_min = Math.min, Math_trunc = Math.trunc, runDependencies = 0, runDependencyWatcher = null, dependenciesFulfilled = null; function getUniqueRunDependency(id) { return id } function addRunDependency(id) { runDependencies++, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies) } function removeRunDependency(id) { if (runDependencies--, Module.monitorRunDependencies && Module.monitorRunDependencies(runDependencies), 0 == runDependencies && (null !== runDependencyWatcher && (clearInterval(runDependencyWatcher), runDependencyWatcher = null), dependenciesFulfilled)) { var callback = dependenciesFulfilled; dependenciesFulfilled = null, callback() } } Module.preloadedImages = {}, Module.preloadedAudios = {}; var dataURIPrefix = "data:application/octet-stream;base64,"; function isDataURI(filename) { return String.prototype.startsWith ? filename.startsWith(dataURIPrefix) : 0 === filename.indexOf(dataURIPrefix) } var wasmBinaryFile = "media-worker.wasm"; function getBinary() { try { if (Module.wasmBinary) return new Uint8Array(Module.wasmBinary); if (Module.readBinary) return Module.readBinary(wasmBinaryFile); throw "both async and sync fetching of the wasm failed" } catch (err) { abort(err) } } function getBinaryPromise() { return Module.wasmBinary || !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER || "function" != typeof fetch ? new Promise((function (resolve, reject) { resolve(getBinary()) })) : fetch(wasmBinaryFile, { credentials: "same-origin" }).then((function (response) { if (!response.ok) throw "failed to load wasm binary file at '" + wasmBinaryFile + "'"; return response.arrayBuffer() })).catch((function () { return getBinary() })) } function createWasm(env) { var info = { env: env, global: { NaN: NaN, Infinity: 1 / 0 }, "global.Math": Math, asm2wasm: asm2wasmImports }; function receiveInstance(instance, module) { var exports = instance.exports; Module.asm = exports, removeRunDependency("wasm-instantiate") } if (addRunDependency("wasm-instantiate"), Module.instantiateWasm) try { return Module.instantiateWasm(info, receiveInstance) } catch (e) { return err("Module.instantiateWasm callback failed with error: " + e), !1 } function receiveInstantiatedSource(output) { receiveInstance(output.instance) } function instantiateArrayBuffer(receiver) { getBinaryPromise().then((function (binary) { return WebAssembly.instantiate(binary, info) })).then(receiver, (function (reason) { err("failed to asynchronously prepare wasm: " + reason), abort(reason) })) } return Module.wasmBinary || "function" != typeof WebAssembly.instantiateStreaming || isDataURI(wasmBinaryFile) || "function" != typeof fetch ? instantiateArrayBuffer(receiveInstantiatedSource) : WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: "same-origin" }), info).then(receiveInstantiatedSource, (function (reason) { err("wasm streaming compile failed: " + reason), err("falling back to ArrayBuffer instantiation"), instantiateArrayBuffer(receiveInstantiatedSource) })), {} } function ___assert_fail(condition, filename, line, func) { abort("Assertion failed: " + UTF8ToString(condition) + ", at: " + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]) } isDataURI(wasmBinaryFile) || (wasmBinaryFile = locateFile(wasmBinaryFile)), Module.asm = function (global, env, providedBuffer) { return env.memory = wasmMemory, env.table = wasmTable = new WebAssembly.Table({ initial: 2570, maximum: 2570, element: "anyfunc" }), env.__memory_base = 1024, env.__table_base = 0, createWasm(env) }, __ATINIT__.push({ func: function () { ___emscripten_environ_constructor() } }); var ENV = {}; function ___buildEnvironment(environ) { var poolPtr, envPtr; ___buildEnvironment.called ? (envPtr = HEAP32[environ >> 2], poolPtr = HEAP32[envPtr >> 2]) : (___buildEnvironment.called = !0, ENV.USER = ENV.LOGNAME = "web_user", ENV.PATH = "/", ENV.PWD = "/", ENV.HOME = "/home/web_user", ENV.LANG = "C.UTF-8", ENV._ = Module.thisProgram, poolPtr = getMemory(1024), envPtr = getMemory(256), HEAP32[envPtr >> 2] = poolPtr, HEAP32[environ >> 2] = envPtr); var strings = [], totalSize = 0; for (var key in ENV) if ("string" == typeof ENV[key]) { var line = key + "=" + ENV[key]; strings.push(line), totalSize += line.length } if (totalSize > 1024) throw new Error("Environment size exceeded TOTAL_ENV_SIZE!"); for (var i = 0; i < strings.length; i++) { writeAsciiToMemory(line = strings[i], poolPtr), HEAP32[envPtr + 4 * i >> 2] = poolPtr, poolPtr += line.length + 1 } HEAP32[envPtr + 4 * strings.length >> 2] = 0 } function ___lock() { } function ___setErrNo(value) { return Module.___errno_location && (HEAP32[Module.___errno_location() >> 2] = value), value } var PATH = { splitPath: function (filename) { return /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(filename).slice(1) }, normalizeArray: function (parts, allowAboveRoot) { for (var up = 0, i = parts.length - 1; i >= 0; i--) { var last = parts[i]; "." === last ? parts.splice(i, 1) : ".." === last ? (parts.splice(i, 1), up++) : up && (parts.splice(i, 1), up--) } if (allowAboveRoot) for (; up; up--)parts.unshift(".."); return parts }, normalize: function (path) { var isAbsolute = "/" === path.charAt(0), trailingSlash = "/" === path.substr(-1); return (path = PATH.normalizeArray(path.split("/").filter((function (p) { return !!p })), !isAbsolute).join("/")) || isAbsolute || (path = "."), path && trailingSlash && (path += "/"), (isAbsolute ? "/" : "") + path }, dirname: function (path) { var result = PATH.splitPath(path), root = result[0], dir = result[1]; return root || dir ? (dir && (dir = dir.substr(0, dir.length - 1)), root + dir) : "." }, basename: function (path) { if ("/" === path) return "/"; var lastSlash = path.lastIndexOf("/"); return -1 === lastSlash ? path : path.substr(lastSlash + 1) }, extname: function (path) { return PATH.splitPath(path)[3] }, join: function () { var paths = Array.prototype.slice.call(arguments, 0); return PATH.normalize(paths.join("/")) }, join2: function (l, r) { return PATH.normalize(l + "/" + r) }, resolve: function () { for (var resolvedPath = "", resolvedAbsolute = !1, i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) { var path = i >= 0 ? arguments[i] : FS.cwd(); if ("string" != typeof path) throw new TypeError("Arguments to path.resolve must be strings"); if (!path) return ""; resolvedPath = path + "/" + resolvedPath, resolvedAbsolute = "/" === path.charAt(0) } return (resolvedAbsolute ? "/" : "") + (resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((function (p) { return !!p })), !resolvedAbsolute).join("/")) || "." }, relative: function (from, to) { function trim(arr) { for (var start = 0; start < arr.length && "" === arr[start]; start++); for (var end = arr.length - 1; end >= 0 && "" === arr[end]; end--); return start > end ? [] : arr.slice(start, end - start + 1) } from = PATH.resolve(from).substr(1), to = PATH.resolve(to).substr(1); for (var fromParts = trim(from.split("/")), toParts = trim(to.split("/")), length = Math.min(fromParts.length, toParts.length), samePartsLength = length, i = 0; i < length; i++)if (fromParts[i] !== toParts[i]) { samePartsLength = i; break } var outputParts = []; for (i = samePartsLength; i < fromParts.length; i++)outputParts.push(".."); return (outputParts = outputParts.concat(toParts.slice(samePartsLength))).join("/") } }, TTY = { ttys: [], init: function () { }, shutdown: function () { }, register: function (dev, ops) { TTY.ttys[dev] = { input: [], output: [], ops: ops }, FS.registerDevice(dev, TTY.stream_ops) }, stream_ops: { open: function (stream) { var tty = TTY.ttys[stream.node.rdev]; if (!tty) throw new FS.ErrnoError(19); stream.tty = tty, stream.seekable = !1 }, close: function (stream) { stream.tty.ops.flush(stream.tty) }, flush: function (stream) { stream.tty.ops.flush(stream.tty) }, read: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.get_char) throw new FS.ErrnoError(6); for (var bytesRead = 0, i = 0; i < length; i++) { var result; try { result = stream.tty.ops.get_char(stream.tty) } catch (e) { throw new FS.ErrnoError(5) } if (void 0 === result && 0 === bytesRead) throw new FS.ErrnoError(11); if (null == result) break; bytesRead++, buffer[offset + i] = result } return bytesRead && (stream.node.timestamp = Date.now()), bytesRead }, write: function (stream, buffer, offset, length, pos) { if (!stream.tty || !stream.tty.ops.put_char) throw new FS.ErrnoError(6); try { for (var i = 0; i < length; i++)stream.tty.ops.put_char(stream.tty, buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(5) } return length && (stream.node.timestamp = Date.now()), i } }, default_tty_ops: { get_char: function (tty) { if (!tty.input.length) { var result = null; if ("undefined" != typeof window && "function" == typeof window.prompt ? null !== (result = window.prompt("Input: ")) && (result += "\n") : "function" == typeof readline && null !== (result = readline()) && (result += "\n"), !result) return null; tty.input = intArrayFromString(result, !0) } return tty.input.shift() }, put_char: function (tty, val) { null === val || 10 === val ? (out(UTF8ArrayToString(tty.output, 0)), tty.output = []) : 0 != val && tty.output.push(val) }, flush: function (tty) { tty.output && tty.output.length > 0 && (out(UTF8ArrayToString(tty.output, 0)), tty.output = []) } }, default_tty1_ops: { put_char: function (tty, val) { null === val || 10 === val ? (err(UTF8ArrayToString(tty.output, 0)), tty.output = []) : 0 != val && tty.output.push(val) }, flush: function (tty) { tty.output && tty.output.length > 0 && (err(UTF8ArrayToString(tty.output, 0)), tty.output = []) } } }, MEMFS = { ops_table: null, mount: function (mount) { return MEMFS.createNode(null, "/", 16895, 0) }, createNode: function (parent, name, mode, dev) { if (FS.isBlkdev(mode) || FS.isFIFO(mode)) throw new FS.ErrnoError(1); MEMFS.ops_table || (MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } }); var node = FS.createNode(parent, name, mode, dev); return FS.isDir(node.mode) ? (node.node_ops = MEMFS.ops_table.dir.node, node.stream_ops = MEMFS.ops_table.dir.stream, node.contents = {}) : FS.isFile(node.mode) ? (node.node_ops = MEMFS.ops_table.file.node, node.stream_ops = MEMFS.ops_table.file.stream, node.usedBytes = 0, node.contents = null) : FS.isLink(node.mode) ? (node.node_ops = MEMFS.ops_table.link.node, node.stream_ops = MEMFS.ops_table.link.stream) : FS.isChrdev(node.mode) && (node.node_ops = MEMFS.ops_table.chrdev.node, node.stream_ops = MEMFS.ops_table.chrdev.stream), node.timestamp = Date.now(), parent && (parent.contents[name] = node), node }, getFileDataAsRegularArray: function (node) { if (node.contents && node.contents.subarray) { for (var arr = [], i = 0; i < node.usedBytes; ++i)arr.push(node.contents[i]); return arr } return node.contents }, getFileDataAsTypedArray: function (node) { return node.contents ? node.contents.subarray ? node.contents.subarray(0, node.usedBytes) : new Uint8Array(node.contents) : new Uint8Array }, expandFileStorage: function (node, newCapacity) { var prevCapacity = node.contents ? node.contents.length : 0; if (!(prevCapacity >= newCapacity)) { newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < 1048576 ? 2 : 1.125) | 0), 0 != prevCapacity && (newCapacity = Math.max(newCapacity, 256)); var oldContents = node.contents; node.contents = new Uint8Array(newCapacity), node.usedBytes > 0 && node.contents.set(oldContents.subarray(0, node.usedBytes), 0) } }, resizeFileStorage: function (node, newSize) { if (node.usedBytes != newSize) { if (0 == newSize) return node.contents = null, void (node.usedBytes = 0); if (!node.contents || node.contents.subarray) { var oldContents = node.contents; return node.contents = new Uint8Array(new ArrayBuffer(newSize)), oldContents && node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))), void (node.usedBytes = newSize) } if (node.contents || (node.contents = []), node.contents.length > newSize) node.contents.length = newSize; else for (; node.contents.length < newSize;)node.contents.push(0); node.usedBytes = newSize } }, node_ops: { getattr: function (node) { var attr = {}; return attr.dev = FS.isChrdev(node.mode) ? node.id : 1, attr.ino = node.id, attr.mode = node.mode, attr.nlink = 1, attr.uid = 0, attr.gid = 0, attr.rdev = node.rdev, FS.isDir(node.mode) ? attr.size = 4096 : FS.isFile(node.mode) ? attr.size = node.usedBytes : FS.isLink(node.mode) ? attr.size = node.link.length : attr.size = 0, attr.atime = new Date(node.timestamp), attr.mtime = new Date(node.timestamp), attr.ctime = new Date(node.timestamp), attr.blksize = 4096, attr.blocks = Math.ceil(attr.size / attr.blksize), attr }, setattr: function (node, attr) { void 0 !== attr.mode && (node.mode = attr.mode), void 0 !== attr.timestamp && (node.timestamp = attr.timestamp), void 0 !== attr.size && MEMFS.resizeFileStorage(node, attr.size) }, lookup: function (parent, name) { throw FS.genericErrors[2] }, mknod: function (parent, name, mode, dev) { return MEMFS.createNode(parent, name, mode, dev) }, rename: function (old_node, new_dir, new_name) { if (FS.isDir(old_node.mode)) { var new_node; try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (new_node) for (var i in new_node.contents) throw new FS.ErrnoError(39) } delete old_node.parent.contents[old_node.name], old_node.name = new_name, new_dir.contents[new_name] = old_node, old_node.parent = new_dir }, unlink: function (parent, name) { delete parent.contents[name] }, rmdir: function (parent, name) { var node = FS.lookupNode(parent, name); for (var i in node.contents) throw new FS.ErrnoError(39); delete parent.contents[name] }, readdir: function (node) { var entries = [".", ".."]; for (var key in node.contents) node.contents.hasOwnProperty(key) && entries.push(key); return entries }, symlink: function (parent, newname, oldpath) { var node = MEMFS.createNode(parent, newname, 41471, 0); return node.link = oldpath, node }, readlink: function (node) { if (!FS.isLink(node.mode)) throw new FS.ErrnoError(22); return node.link } }, stream_ops: { read: function (stream, buffer, offset, length, position) { var contents = stream.node.contents; if (position >= stream.node.usedBytes) return 0; var size = Math.min(stream.node.usedBytes - position, length); if (size > 8 && contents.subarray) buffer.set(contents.subarray(position, position + size), offset); else for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i]; return size }, write: function (stream, buffer, offset, length, position, canOwn) { if (!1, !length) return 0; var node = stream.node; if (node.timestamp = Date.now(), buffer.subarray && (!node.contents || node.contents.subarray)) { if (0 === node.usedBytes && 0 === position) return node.contents = new Uint8Array(buffer.subarray(offset, offset + length)), node.usedBytes = length, length; if (position + length <= node.usedBytes) return node.contents.set(buffer.subarray(offset, offset + length), position), length } if (MEMFS.expandFileStorage(node, position + length), node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); else for (var i = 0; i < length; i++)node.contents[position + i] = buffer[offset + i]; return node.usedBytes = Math.max(node.usedBytes, position + length), length }, llseek: function (stream, offset, whence) { var position = offset; if (1 === whence ? position += stream.position : 2 === whence && FS.isFile(stream.node.mode) && (position += stream.node.usedBytes), position < 0) throw new FS.ErrnoError(22); return position }, allocate: function (stream, offset, length) { MEMFS.expandFileStorage(stream.node, offset + length), stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(19); var ptr, allocated, contents = stream.node.contents; if (2 & flags || contents.buffer !== buffer && contents.buffer !== buffer.buffer) { if ((position > 0 || position + length < stream.node.usedBytes) && (contents = contents.subarray ? contents.subarray(position, position + length) : Array.prototype.slice.call(contents, position, position + length)), allocated = !0, !(ptr = _malloc(length))) throw new FS.ErrnoError(12); buffer.set(contents, ptr) } else allocated = !1, ptr = contents.byteOffset; return { ptr: ptr, allocated: allocated } }, msync: function (stream, buffer, offset, length, mmapFlags) { if (!FS.isFile(stream.node.mode)) throw new FS.ErrnoError(19); if (2 & mmapFlags) return 0; MEMFS.stream_ops.write(stream, buffer, 0, length, offset, !1); return 0 } } }, IDBFS = { dbs: {}, indexedDB: function () { if ("undefined" != typeof indexedDB) return indexedDB; var ret = null; return "object" == typeof window && (ret = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB), assert(ret, "IDBFS used, but indexedDB not supported"), ret }, DB_VERSION: 21, DB_STORE_NAME: "FILE_DATA", mount: function (mount) { return MEMFS.mount.apply(null, arguments) }, syncfs: function (mount, populate, callback) { IDBFS.getLocalSet(mount, (function (err, local) { if (err) return callback(err); IDBFS.getRemoteSet(mount, (function (err, remote) { if (err) return callback(err); var src = populate ? remote : local, dst = populate ? local : remote; IDBFS.reconcile(src, dst, callback) })) })) }, getDB: function (name, callback) { var req, db = IDBFS.dbs[name]; if (db) return callback(null, db); try { req = IDBFS.indexedDB().open(name, IDBFS.DB_VERSION) } catch (e) { return callback(e) } if (!req) return callback("Unable to connect to IndexedDB"); req.onupgradeneeded = function (e) { var fileStore, db = e.target.result, transaction = e.target.transaction; (fileStore = db.objectStoreNames.contains(IDBFS.DB_STORE_NAME) ? transaction.objectStore(IDBFS.DB_STORE_NAME) : db.createObjectStore(IDBFS.DB_STORE_NAME)).indexNames.contains("timestamp") || fileStore.createIndex("timestamp", "timestamp", { unique: !1 }) }, req.onsuccess = function () { db = req.result, IDBFS.dbs[name] = db, callback(null, db) }, req.onerror = function (e) { callback(this.error), e.preventDefault() } }, getLocalSet: function (mount, callback) { var entries = {}; function isRealDir(p) { return "." !== p && ".." !== p } function toAbsolute(root) { return function (p) { return PATH.join2(root, p) } } for (var check = FS.readdir(mount.mountpoint).filter(isRealDir).map(toAbsolute(mount.mountpoint)); check.length;) { var stat, path = check.pop(); try { stat = FS.stat(path) } catch (e) { return callback(e) } FS.isDir(stat.mode) && check.push.apply(check, FS.readdir(path).filter(isRealDir).map(toAbsolute(path))), entries[path] = { timestamp: stat.mtime } } return callback(null, { type: "local", entries: entries }) }, getRemoteSet: function (mount, callback) { var entries = {}; IDBFS.getDB(mount.mountpoint, (function (err, db) { if (err) return callback(err); try { var transaction = db.transaction([IDBFS.DB_STORE_NAME], "readonly"); transaction.onerror = function (e) { callback(this.error), e.preventDefault() }, transaction.objectStore(IDBFS.DB_STORE_NAME).index("timestamp").openKeyCursor().onsuccess = function (event) { var cursor = event.target.result; if (!cursor) return callback(null, { type: "remote", db: db, entries: entries }); entries[cursor.primaryKey] = { timestamp: cursor.key }, cursor.continue() } } catch (e) { return callback(e) } })) }, loadLocalEntry: function (path, callback) { var stat, node; try { node = FS.lookupPath(path).node, stat = FS.stat(path) } catch (e) { return callback(e) } return FS.isDir(stat.mode) ? callback(null, { timestamp: stat.mtime, mode: stat.mode }) : FS.isFile(stat.mode) ? (node.contents = MEMFS.getFileDataAsTypedArray(node), callback(null, { timestamp: stat.mtime, mode: stat.mode, contents: node.contents })) : callback(new Error("node type not supported")) }, storeLocalEntry: function (path, entry, callback) { try { if (FS.isDir(entry.mode)) FS.mkdir(path, entry.mode); else { if (!FS.isFile(entry.mode)) return callback(new Error("node type not supported")); FS.writeFile(path, entry.contents, { canOwn: !0 }) } FS.chmod(path, entry.mode), FS.utime(path, entry.timestamp, entry.timestamp) } catch (e) { return callback(e) } callback(null) }, removeLocalEntry: function (path, callback) { try { FS.lookupPath(path); var stat = FS.stat(path); FS.isDir(stat.mode) ? FS.rmdir(path) : FS.isFile(stat.mode) && FS.unlink(path) } catch (e) { return callback(e) } callback(null) }, loadRemoteEntry: function (store, path, callback) { var req = store.get(path); req.onsuccess = function (event) { callback(null, event.target.result) }, req.onerror = function (e) { callback(this.error), e.preventDefault() } }, storeRemoteEntry: function (store, path, entry, callback) { var req = store.put(entry, path); req.onsuccess = function () { callback(null) }, req.onerror = function (e) { callback(this.error), e.preventDefault() } }, removeRemoteEntry: function (store, path, callback) { var req = store.delete(path); req.onsuccess = function () { callback(null) }, req.onerror = function (e) { callback(this.error), e.preventDefault() } }, reconcile: function (src, dst, callback) { var total = 0, create = []; Object.keys(src.entries).forEach((function (key) { var e = src.entries[key], e2 = dst.entries[key]; (!e2 || e.timestamp > e2.timestamp) && (create.push(key), total++) })); var remove = []; if (Object.keys(dst.entries).forEach((function (key) { dst.entries[key]; src.entries[key] || (remove.push(key), total++) })), !total) return callback(null); var completed = 0, transaction = ("remote" === src.type ? src.db : dst.db).transaction([IDBFS.DB_STORE_NAME], "readwrite"), store = transaction.objectStore(IDBFS.DB_STORE_NAME); function done(err) { return err ? done.errored ? void 0 : (done.errored = !0, callback(err)) : ++completed >= total ? callback(null) : void 0 } transaction.onerror = function (e) { done(this.error), e.preventDefault() }, create.sort().forEach((function (path) { "local" === dst.type ? IDBFS.loadRemoteEntry(store, path, (function (err, entry) { if (err) return done(err); IDBFS.storeLocalEntry(path, entry, done) })) : IDBFS.loadLocalEntry(path, (function (err, entry) { if (err) return done(err); IDBFS.storeRemoteEntry(store, path, entry, done) })) })), remove.sort().reverse().forEach((function (path) { "local" === dst.type ? IDBFS.removeLocalEntry(path, done) : IDBFS.removeRemoteEntry(store, path, done) })) } }, WORKERFS = { DIR_MODE: 16895, FILE_MODE: 33279, reader: null, mount: function (mount) { assert(ENVIRONMENT_IS_WORKER), WORKERFS.reader || (WORKERFS.reader = new FileReaderSync); var root = WORKERFS.createNode(null, "/", WORKERFS.DIR_MODE, 0), createdParents = {}; function ensureParent(path) { for (var parts = path.split("/"), parent = root, i = 0; i < parts.length - 1; i++) { var curr = parts.slice(0, i + 1).join("/"); createdParents[curr] || (createdParents[curr] = WORKERFS.createNode(parent, parts[i], WORKERFS.DIR_MODE, 0)), parent = createdParents[curr] } return parent } function base(path) { var parts = path.split("/"); return parts[parts.length - 1] } return Array.prototype.forEach.call(mount.opts.files || [], (function (file) { WORKERFS.createNode(ensureParent(file.name), base(file.name), WORKERFS.FILE_MODE, 0, file, file.lastModifiedDate) })), (mount.opts.blobs || []).forEach((function (obj) { WORKERFS.createNode(ensureParent(obj.name), base(obj.name), WORKERFS.FILE_MODE, 0, obj.data) })), (mount.opts.packages || []).forEach((function (pack) { pack.metadata.files.forEach((function (file) { var name = file.filename.substr(1); WORKERFS.createNode(ensureParent(name), base(name), WORKERFS.FILE_MODE, 0, pack.blob.slice(file.start, file.end)) })) })), root }, createNode: function (parent, name, mode, dev, contents, mtime) { var node = FS.createNode(parent, name, mode); return node.mode = mode, node.node_ops = WORKERFS.node_ops, node.stream_ops = WORKERFS.stream_ops, node.timestamp = (mtime || new Date).getTime(), assert(WORKERFS.FILE_MODE !== WORKERFS.DIR_MODE), mode === WORKERFS.FILE_MODE ? (node.size = contents.size, node.contents = contents) : (node.size = 4096, node.contents = {}), parent && (parent.contents[name] = node), node }, node_ops: { getattr: function (node) { return { dev: 1, ino: void 0, mode: node.mode, nlink: 1, uid: 0, gid: 0, rdev: void 0, size: node.size, atime: new Date(node.timestamp), mtime: new Date(node.timestamp), ctime: new Date(node.timestamp), blksize: 4096, blocks: Math.ceil(node.size / 4096) } }, setattr: function (node, attr) { void 0 !== attr.mode && (node.mode = attr.mode), void 0 !== attr.timestamp && (node.timestamp = attr.timestamp) }, lookup: function (parent, name) { throw new FS.ErrnoError(2) }, mknod: function (parent, name, mode, dev) { throw new FS.ErrnoError(1) }, rename: function (oldNode, newDir, newName) { throw new FS.ErrnoError(1) }, unlink: function (parent, name) { throw new FS.ErrnoError(1) }, rmdir: function (parent, name) { throw new FS.ErrnoError(1) }, readdir: function (node) { var entries = [".", ".."]; for (var key in node.contents) node.contents.hasOwnProperty(key) && entries.push(key); return entries }, symlink: function (parent, newName, oldPath) { throw new FS.ErrnoError(1) }, readlink: function (node) { throw new FS.ErrnoError(1) } }, stream_ops: { read: function (stream, buffer, offset, length, position) { if (position >= stream.node.size) return 0; var chunk = stream.node.contents.slice(position, position + length), ab = WORKERFS.reader.readAsArrayBuffer(chunk); return buffer.set(new Uint8Array(ab), offset), chunk.size }, write: function (stream, buffer, offset, length, position) { throw new FS.ErrnoError(5) }, llseek: function (stream, offset, whence) { var position = offset; if (1 === whence ? position += stream.position : 2 === whence && FS.isFile(stream.node.mode) && (position += stream.node.size), position < 0) throw new FS.ErrnoError(22); return position } } }, FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: !1, ignorePermissions: !0, trackingDelegate: {}, tracking: { openFlags: { READ: 1, WRITE: 2 } }, ErrnoError: null, genericErrors: {}, filesystems: null, syncFSRequests: 0, handleFSError: function (e) { if (!(e instanceof FS.ErrnoError)) throw e + " : " + stackTrace(); return ___setErrNo(e.errno) }, lookupPath: function (path, opts) { if (opts = opts || {}, !(path = PATH.resolve(FS.cwd(), path))) return { path: "", node: null }; var defaults = { follow_mount: !0, recurse_count: 0 }; for (var key in defaults) void 0 === opts[key] && (opts[key] = defaults[key]); if (opts.recurse_count > 8) throw new FS.ErrnoError(40); for (var parts = PATH.normalizeArray(path.split("/").filter((function (p) { return !!p })), !1), current = FS.root, current_path = "/", i = 0; i < parts.length; i++) { var islast = i === parts.length - 1; if (islast && opts.parent) break; if (current = FS.lookupNode(current, parts[i]), current_path = PATH.join2(current_path, parts[i]), FS.isMountpoint(current) && (!islast || islast && opts.follow_mount) && (current = current.mounted.root), !islast || opts.follow) for (var count = 0; FS.isLink(current.mode);) { var link = FS.readlink(current_path); if (current_path = PATH.resolve(PATH.dirname(current_path), link), current = FS.lookupPath(current_path, { recurse_count: opts.recurse_count }).node, count++ > 40) throw new FS.ErrnoError(40) } } return { path: current_path, node: current } }, getPath: function (node) { for (var path; ;) { if (FS.isRoot(node)) { var mount = node.mount.mountpoint; return path ? "/" !== mount[mount.length - 1] ? mount + "/" + path : mount + path : mount } path = path ? node.name + "/" + path : node.name, node = node.parent } }, hashName: function (parentid, name) { for (var hash = 0, i = 0; i < name.length; i++)hash = (hash << 5) - hash + name.charCodeAt(i) | 0; return (parentid + hash >>> 0) % FS.nameTable.length }, hashAddNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); node.name_next = FS.nameTable[hash], FS.nameTable[hash] = node }, hashRemoveNode: function (node) { var hash = FS.hashName(node.parent.id, node.name); if (FS.nameTable[hash] === node) FS.nameTable[hash] = node.name_next; else for (var current = FS.nameTable[hash]; current;) { if (current.name_next === node) { current.name_next = node.name_next; break } current = current.name_next } }, lookupNode: function (parent, name) { var err = FS.mayLookup(parent); if (err) throw new FS.ErrnoError(err, parent); for (var hash = FS.hashName(parent.id, name), node = FS.nameTable[hash]; node; node = node.name_next) { var nodeName = node.name; if (node.parent.id === parent.id && nodeName === name) return node } return FS.lookup(parent, name) }, createNode: function (parent, name, mode, rdev) { if (!FS.FSNode) { FS.FSNode = function (parent, name, mode, rdev) { parent || (parent = this), this.parent = parent, this.mount = parent.mount, this.mounted = null, this.id = FS.nextInode++, this.name = name, this.mode = mode, this.node_ops = {}, this.stream_ops = {}, this.rdev = rdev }, FS.FSNode.prototype = {}; Object.defineProperties(FS.FSNode.prototype, { read: { get: function () { return 365 == (365 & this.mode) }, set: function (val) { val ? this.mode |= 365 : this.mode &= -366 } }, write: { get: function () { return 146 == (146 & this.mode) }, set: function (val) { val ? this.mode |= 146 : this.mode &= -147 } }, isFolder: { get: function () { return FS.isDir(this.mode) } }, isDevice: { get: function () { return FS.isChrdev(this.mode) } } }) } var node = new FS.FSNode(parent, name, mode, rdev); return FS.hashAddNode(node), node }, destroyNode: function (node) { FS.hashRemoveNode(node) }, isRoot: function (node) { return node === node.parent }, isMountpoint: function (node) { return !!node.mounted }, isFile: function (mode) { return 32768 == (61440 & mode) }, isDir: function (mode) { return 16384 == (61440 & mode) }, isLink: function (mode) { return 40960 == (61440 & mode) }, isChrdev: function (mode) { return 8192 == (61440 & mode) }, isBlkdev: function (mode) { return 24576 == (61440 & mode) }, isFIFO: function (mode) { return 4096 == (61440 & mode) }, isSocket: function (mode) { return 49152 == (49152 & mode) }, flagModes: { r: 0, rs: 1052672, "r+": 2, w: 577, wx: 705, xw: 705, "w+": 578, "wx+": 706, "xw+": 706, a: 1089, ax: 1217, xa: 1217, "a+": 1090, "ax+": 1218, "xa+": 1218 }, modeStringToFlags: function (str) { var flags = FS.flagModes[str]; if (void 0 === flags) throw new Error("Unknown file open mode: " + str); return flags }, flagsToPermissionString: function (flag) { var perms = ["r", "w", "rw"][3 & flag]; return 512 & flag && (perms += "w"), perms }, nodePermissions: function (node, perms) { return FS.ignorePermissions ? 0 : (-1 === perms.indexOf("r") || 292 & node.mode) && (-1 === perms.indexOf("w") || 146 & node.mode) && (-1 === perms.indexOf("x") || 73 & node.mode) ? 0 : 13 }, mayLookup: function (dir) { var err = FS.nodePermissions(dir, "x"); return err || (dir.node_ops.lookup ? 0 : 13) }, mayCreate: function (dir, name) { try { FS.lookupNode(dir, name); return 17 } catch (e) { } return FS.nodePermissions(dir, "wx") }, mayDelete: function (dir, name, isdir) { var node; try { node = FS.lookupNode(dir, name) } catch (e) { return e.errno } var err = FS.nodePermissions(dir, "wx"); if (err) return err; if (isdir) { if (!FS.isDir(node.mode)) return 20; if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) return 16 } else if (FS.isDir(node.mode)) return 21; return 0 }, mayOpen: function (node, flags) { return node ? FS.isLink(node.mode) ? 40 : FS.isDir(node.mode) && ("r" !== FS.flagsToPermissionString(flags) || 512 & flags) ? 21 : FS.nodePermissions(node, FS.flagsToPermissionString(flags)) : 2 }, MAX_OPEN_FDS: 4096, nextfd: function (fd_start, fd_end) { fd_start = fd_start || 0, fd_end = fd_end || FS.MAX_OPEN_FDS; for (var fd = fd_start; fd <= fd_end; fd++)if (!FS.streams[fd]) return fd; throw new FS.ErrnoError(24) }, getStream: function (fd) { return FS.streams[fd] }, createStream: function (stream, fd_start, fd_end) { FS.FSStream || (FS.FSStream = function () { }, FS.FSStream.prototype = {}, Object.defineProperties(FS.FSStream.prototype, { object: { get: function () { return this.node }, set: function (val) { this.node = val } }, isRead: { get: function () { return 1 != (2097155 & this.flags) } }, isWrite: { get: function () { return 0 != (2097155 & this.flags) } }, isAppend: { get: function () { return 1024 & this.flags } } })); var newStream = new FS.FSStream; for (var p in stream) newStream[p] = stream[p]; stream = newStream; var fd = FS.nextfd(fd_start, fd_end); return stream.fd = fd, FS.streams[fd] = stream, stream }, closeStream: function (fd) { FS.streams[fd] = null }, chrdev_stream_ops: { open: function (stream) { var device = FS.getDevice(stream.node.rdev); stream.stream_ops = device.stream_ops, stream.stream_ops.open && stream.stream_ops.open(stream) }, llseek: function () { throw new FS.ErrnoError(29) } }, major: function (dev) { return dev >> 8 }, minor: function (dev) { return 255 & dev }, makedev: function (ma, mi) { return ma << 8 | mi }, registerDevice: function (dev, ops) { FS.devices[dev] = { stream_ops: ops } }, getDevice: function (dev) { return FS.devices[dev] }, getMounts: function (mount) { for (var mounts = [], check = [mount]; check.length;) { var m = check.pop(); mounts.push(m), check.push.apply(check, m.mounts) } return mounts }, syncfs: function (populate, callback) { "function" == typeof populate && (callback = populate, populate = !1), FS.syncFSRequests++, FS.syncFSRequests; var mounts = FS.getMounts(FS.root.mount), completed = 0; function doCallback(err) { return FS.syncFSRequests--, callback(err) } function done(err) { if (err) return done.errored ? void 0 : (done.errored = !0, doCallback(err)); ++completed >= mounts.length && doCallback(null) } mounts.forEach((function (mount) { if (!mount.type.syncfs) return done(null); mount.type.syncfs(mount, populate, done) })) }, mount: function (type, opts, mountpoint) { var node, root = "/" === mountpoint, pseudo = !mountpoint; if (root && FS.root) throw new FS.ErrnoError(16); if (!root && !pseudo) { var lookup = FS.lookupPath(mountpoint, { follow_mount: !1 }); if (mountpoint = lookup.path, node = lookup.node, FS.isMountpoint(node)) throw new FS.ErrnoError(16); if (!FS.isDir(node.mode)) throw new FS.ErrnoError(20) } var mount = { type: type, opts: opts, mountpoint: mountpoint, mounts: [] }, mountRoot = type.mount(mount); return mountRoot.mount = mount, mount.root = mountRoot, root ? FS.root = mountRoot : node && (node.mounted = mount, node.mount && node.mount.mounts.push(mount)), mountRoot }, unmount: function (mountpoint) { var lookup = FS.lookupPath(mountpoint, { follow_mount: !1 }); if (!FS.isMountpoint(lookup.node)) throw new FS.ErrnoError(22); var node = lookup.node, mount = node.mounted, mounts = FS.getMounts(mount); Object.keys(FS.nameTable).forEach((function (hash) { for (var current = FS.nameTable[hash]; current;) { var next = current.name_next; -1 !== mounts.indexOf(current.mount) && FS.destroyNode(current), current = next } })), node.mounted = null; var idx = node.mount.mounts.indexOf(mount); node.mount.mounts.splice(idx, 1) }, lookup: function (parent, name) { return parent.node_ops.lookup(parent, name) }, mknod: function (path, mode, dev) { var parent = FS.lookupPath(path, { parent: !0 }).node, name = PATH.basename(path); if (!name || "." === name || ".." === name) throw new FS.ErrnoError(22); var err = FS.mayCreate(parent, name); if (err) throw new FS.ErrnoError(err); if (!parent.node_ops.mknod) throw new FS.ErrnoError(1); return parent.node_ops.mknod(parent, name, mode, dev) }, create: function (path, mode) { return mode = void 0 !== mode ? mode : 438, mode &= 4095, mode |= 32768, FS.mknod(path, mode, 0) }, mkdir: function (path, mode) { return mode = void 0 !== mode ? mode : 511, mode &= 1023, mode |= 16384, FS.mknod(path, mode, 0) }, mkdirTree: function (path, mode) { for (var dirs = path.split("/"), d = "", i = 0; i < dirs.length; ++i)if (dirs[i]) { d += "/" + dirs[i]; try { FS.mkdir(d, mode) } catch (e) { if (17 != e.errno) throw e } } }, mkdev: function (path, mode, dev) { return void 0 === dev && (dev = mode, mode = 438), mode |= 8192, FS.mknod(path, mode, dev) }, symlink: function (oldpath, newpath) { if (!PATH.resolve(oldpath)) throw new FS.ErrnoError(2); var parent = FS.lookupPath(newpath, { parent: !0 }).node; if (!parent) throw new FS.ErrnoError(2); var newname = PATH.basename(newpath), err = FS.mayCreate(parent, newname); if (err) throw new FS.ErrnoError(err); if (!parent.node_ops.symlink) throw new FS.ErrnoError(1); return parent.node_ops.symlink(parent, newname, oldpath) }, rename: function (old_path, new_path) { var old_dir, new_dir, old_dirname = PATH.dirname(old_path), new_dirname = PATH.dirname(new_path), old_name = PATH.basename(old_path), new_name = PATH.basename(new_path); try { old_dir = FS.lookupPath(old_path, { parent: !0 }).node, new_dir = FS.lookupPath(new_path, { parent: !0 }).node } catch (e) { throw new FS.ErrnoError(16) } if (!old_dir || !new_dir) throw new FS.ErrnoError(2); if (old_dir.mount !== new_dir.mount) throw new FS.ErrnoError(18); var new_node, old_node = FS.lookupNode(old_dir, old_name), relative = PATH.relative(old_path, new_dirname); if ("." !== relative.charAt(0)) throw new FS.ErrnoError(22); if ("." !== (relative = PATH.relative(new_path, old_dirname)).charAt(0)) throw new FS.ErrnoError(39); try { new_node = FS.lookupNode(new_dir, new_name) } catch (e) { } if (old_node !== new_node) { var isdir = FS.isDir(old_node.mode), err = FS.mayDelete(old_dir, old_name, isdir); if (err) throw new FS.ErrnoError(err); if (err = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name)) throw new FS.ErrnoError(err); if (!old_dir.node_ops.rename) throw new FS.ErrnoError(1); if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) throw new FS.ErrnoError(16); if (new_dir !== old_dir && (err = FS.nodePermissions(old_dir, "w"))) throw new FS.ErrnoError(err); try { FS.trackingDelegate.willMovePath && FS.trackingDelegate.willMovePath(old_path, new_path) } catch (e) { } FS.hashRemoveNode(old_node); try { old_dir.node_ops.rename(old_node, new_dir, new_name) } catch (e) { throw e } finally { FS.hashAddNode(old_node) } try { FS.trackingDelegate.onMovePath && FS.trackingDelegate.onMovePath(old_path, new_path) } catch (e) { } } }, rmdir: function (path) { var parent = FS.lookupPath(path, { parent: !0 }).node, name = PATH.basename(path), node = FS.lookupNode(parent, name), err = FS.mayDelete(parent, name, !0); if (err) throw new FS.ErrnoError(err); if (!parent.node_ops.rmdir) throw new FS.ErrnoError(1); if (FS.isMountpoint(node)) throw new FS.ErrnoError(16); try { FS.trackingDelegate.willDeletePath && FS.trackingDelegate.willDeletePath(path) } catch (e) { } parent.node_ops.rmdir(parent, name), FS.destroyNode(node); try { FS.trackingDelegate.onDeletePath && FS.trackingDelegate.onDeletePath(path) } catch (e) { } }, readdir: function (path) { var node = FS.lookupPath(path, { follow: !0 }).node; if (!node.node_ops.readdir) throw new FS.ErrnoError(20); return node.node_ops.readdir(node) }, unlink: function (path) { var parent = FS.lookupPath(path, { parent: !0 }).node, name = PATH.basename(path), node = FS.lookupNode(parent, name), err = FS.mayDelete(parent, name, !1); if (err) throw new FS.ErrnoError(err); if (!parent.node_ops.unlink) throw new FS.ErrnoError(1); if (FS.isMountpoint(node)) throw new FS.ErrnoError(16); try { FS.trackingDelegate.willDeletePath && FS.trackingDelegate.willDeletePath(path) } catch (e) { } parent.node_ops.unlink(parent, name), FS.destroyNode(node); try { FS.trackingDelegate.onDeletePath && FS.trackingDelegate.onDeletePath(path) } catch (e) { } }, readlink: function (path) { var link = FS.lookupPath(path).node; if (!link) throw new FS.ErrnoError(2); if (!link.node_ops.readlink) throw new FS.ErrnoError(22); return PATH.resolve(FS.getPath(link.parent), link.node_ops.readlink(link)) }, stat: function (path, dontFollow) { var node = FS.lookupPath(path, { follow: !dontFollow }).node; if (!node) throw new FS.ErrnoError(2); if (!node.node_ops.getattr) throw new FS.ErrnoError(1); return node.node_ops.getattr(node) }, lstat: function (path) { return FS.stat(path, !0) }, chmod: function (path, mode, dontFollow) { var node; "string" == typeof path ? node = FS.lookupPath(path, { follow: !dontFollow }).node : node = path; if (!node.node_ops.setattr) throw new FS.ErrnoError(1); node.node_ops.setattr(node, { mode: 4095 & mode | -4096 & node.mode, timestamp: Date.now() }) }, lchmod: function (path, mode) { FS.chmod(path, mode, !0) }, fchmod: function (fd, mode) { var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(9); FS.chmod(stream.node, mode) }, chown: function (path, uid, gid, dontFollow) { var node; "string" == typeof path ? node = FS.lookupPath(path, { follow: !dontFollow }).node : node = path; if (!node.node_ops.setattr) throw new FS.ErrnoError(1); node.node_ops.setattr(node, { timestamp: Date.now() }) }, lchown: function (path, uid, gid) { FS.chown(path, uid, gid, !0) }, fchown: function (fd, uid, gid) { var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(9); FS.chown(stream.node, uid, gid) }, truncate: function (path, len) { if (len < 0) throw new FS.ErrnoError(22); var node; "string" == typeof path ? node = FS.lookupPath(path, { follow: !0 }).node : node = path; if (!node.node_ops.setattr) throw new FS.ErrnoError(1); if (FS.isDir(node.mode)) throw new FS.ErrnoError(21); if (!FS.isFile(node.mode)) throw new FS.ErrnoError(22); var err = FS.nodePermissions(node, "w"); if (err) throw new FS.ErrnoError(err); node.node_ops.setattr(node, { size: len, timestamp: Date.now() }) }, ftruncate: function (fd, len) { var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(9); if (0 == (2097155 & stream.flags)) throw new FS.ErrnoError(22); FS.truncate(stream.node, len) }, utime: function (path, atime, mtime) { var node = FS.lookupPath(path, { follow: !0 }).node; node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) }) }, open: function (path, flags, mode, fd_start, fd_end) { if ("" === path) throw new FS.ErrnoError(2); var node; if (mode = void 0 === mode ? 438 : mode, mode = 64 & (flags = "string" == typeof flags ? FS.modeStringToFlags(flags) : flags) ? 4095 & mode | 32768 : 0, "object" == typeof path) node = path; else { path = PATH.normalize(path); try { node = FS.lookupPath(path, { follow: !(131072 & flags) }).node } catch (e) { } } var created = !1; if (64 & flags) if (node) { if (128 & flags) throw new FS.ErrnoError(17) } else node = FS.mknod(path, mode, 0), created = !0; if (!node) throw new FS.ErrnoError(2); if (FS.isChrdev(node.mode) && (flags &= -513), 65536 & flags && !FS.isDir(node.mode)) throw new FS.ErrnoError(20); if (!created) { var err = FS.mayOpen(node, flags); if (err) throw new FS.ErrnoError(err) } 512 & flags && FS.truncate(node, 0), flags &= -641; var stream = FS.createStream({ node: node, path: FS.getPath(node), flags: flags, seekable: !0, position: 0, stream_ops: node.stream_ops, ungotten: [], error: !1 }, fd_start, fd_end); stream.stream_ops.open && stream.stream_ops.open(stream), !Module.logReadFiles || 1 & flags || (FS.readFiles || (FS.readFiles = {}), path in FS.readFiles || (FS.readFiles[path] = 1)); try { if (FS.trackingDelegate.onOpenFile) { var trackingFlags = 0; 1 != (2097155 & flags) && (trackingFlags |= FS.tracking.openFlags.READ), 0 != (2097155 & flags) && (trackingFlags |= FS.tracking.openFlags.WRITE), FS.trackingDelegate.onOpenFile(path, trackingFlags) } } catch (e) { } return stream }, close: function (stream) { if (FS.isClosed(stream)) throw new FS.ErrnoError(9); stream.getdents && (stream.getdents = null); try { stream.stream_ops.close && stream.stream_ops.close(stream) } catch (e) { throw e } finally { FS.closeStream(stream.fd) } stream.fd = null }, isClosed: function (stream) { return null === stream.fd }, llseek: function (stream, offset, whence) { if (FS.isClosed(stream)) throw new FS.ErrnoError(9); if (!stream.seekable || !stream.stream_ops.llseek) throw new FS.ErrnoError(29); if (0 != whence && 1 != whence && 2 != whence) throw new FS.ErrnoError(22); return stream.position = stream.stream_ops.llseek(stream, offset, whence), stream.ungotten = [], stream.position }, read: function (stream, buffer, offset, length, position) { if (length < 0 || position < 0) throw new FS.ErrnoError(22); if (FS.isClosed(stream)) throw new FS.ErrnoError(9); if (1 == (2097155 & stream.flags)) throw new FS.ErrnoError(9); if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(21); if (!stream.stream_ops.read) throw new FS.ErrnoError(22); var seeking = void 0 !== position; if (seeking) { if (!stream.seekable) throw new FS.ErrnoError(29) } else position = stream.position; var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position); return seeking || (stream.position += bytesRead), bytesRead }, write: function (stream, buffer, offset, length, position, canOwn) { if (length < 0 || position < 0) throw new FS.ErrnoError(22); if (FS.isClosed(stream)) throw new FS.ErrnoError(9); if (0 == (2097155 & stream.flags)) throw new FS.ErrnoError(9); if (FS.isDir(stream.node.mode)) throw new FS.ErrnoError(21); if (!stream.stream_ops.write) throw new FS.ErrnoError(22); 1024 & stream.flags && FS.llseek(stream, 0, 2); var seeking = void 0 !== position; if (seeking) { if (!stream.seekable) throw new FS.ErrnoError(29) } else position = stream.position; var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn); seeking || (stream.position += bytesWritten); try { stream.path && FS.trackingDelegate.onWriteToFile && FS.trackingDelegate.onWriteToFile(stream.path) } catch (e) { } return bytesWritten }, allocate: function (stream, offset, length) { if (FS.isClosed(stream)) throw new FS.ErrnoError(9); if (offset < 0 || length <= 0) throw new FS.ErrnoError(22); if (0 == (2097155 & stream.flags)) throw new FS.ErrnoError(9); if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) throw new FS.ErrnoError(19); if (!stream.stream_ops.allocate) throw new FS.ErrnoError(95); stream.stream_ops.allocate(stream, offset, length) }, mmap: function (stream, buffer, offset, length, position, prot, flags) { if (1 == (2097155 & stream.flags)) throw new FS.ErrnoError(13); if (!stream.stream_ops.mmap) throw new FS.ErrnoError(19); return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags) }, msync: function (stream, buffer, offset, length, mmapFlags) { return stream && stream.stream_ops.msync ? stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags) : 0 }, munmap: function (stream) { return 0 }, ioctl: function (stream, cmd, arg) { if (!stream.stream_ops.ioctl) throw new FS.ErrnoError(25); return stream.stream_ops.ioctl(stream, cmd, arg) }, readFile: function (path, opts) { if ((opts = opts || {}).flags = opts.flags || "r", opts.encoding = opts.encoding || "binary", "utf8" !== opts.encoding && "binary" !== opts.encoding) throw new Error('Invalid encoding type "' + opts.encoding + '"'); var ret, stream = FS.open(path, opts.flags), length = FS.stat(path).size, buf = new Uint8Array(length); return FS.read(stream, buf, 0, length, 0), "utf8" === opts.encoding ? ret = UTF8ArrayToString(buf, 0) : "binary" === opts.encoding && (ret = buf), FS.close(stream), ret }, writeFile: function (path, data, opts) { (opts = opts || {}).flags = opts.flags || "w"; var stream = FS.open(path, opts.flags, opts.mode); if ("string" == typeof data) { var buf = new Uint8Array(lengthBytesUTF8(data) + 1), actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length); FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn) } else { if (!ArrayBuffer.isView(data)) throw new Error("Unsupported data type"); FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn) } FS.close(stream) }, cwd: function () { return FS.currentPath }, chdir: function (path) { var lookup = FS.lookupPath(path, { follow: !0 }); if (null === lookup.node) throw new FS.ErrnoError(2); if (!FS.isDir(lookup.node.mode)) throw new FS.ErrnoError(20); var err = FS.nodePermissions(lookup.node, "x"); if (err) throw new FS.ErrnoError(err); FS.currentPath = lookup.path }, createDefaultDirectories: function () { FS.mkdir("/tmp"), FS.mkdir("/home"), FS.mkdir("/home/web_user") }, createDefaultDevices: function () { var random_device; if (FS.mkdir("/dev"), FS.registerDevice(FS.makedev(1, 3), { read: function () { return 0 }, write: function (stream, buffer, offset, length, pos) { return length } }), FS.mkdev("/dev/null", FS.makedev(1, 3)), TTY.register(FS.makedev(5, 0), TTY.default_tty_ops), TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops), FS.mkdev("/dev/tty", FS.makedev(5, 0)), FS.mkdev("/dev/tty1", FS.makedev(6, 0)), "object" == typeof crypto && "function" == typeof crypto.getRandomValues) { var randomBuffer = new Uint8Array(1); random_device = function () { return crypto.getRandomValues(randomBuffer), randomBuffer[0] } } random_device || (random_device = function () { abort("random_device") }), FS.createDevice("/dev", "random", random_device), FS.createDevice("/dev", "urandom", random_device), FS.mkdir("/dev/shm"), FS.mkdir("/dev/shm/tmp") }, createSpecialDirectories: function () { FS.mkdir("/proc"), FS.mkdir("/proc/self"), FS.mkdir("/proc/self/fd"), FS.mount({ mount: function () { var node = FS.createNode("/proc/self", "fd", 16895, 73); return node.node_ops = { lookup: function (parent, name) { var fd = +name, stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(9); var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: function () { return stream.path } } }; return ret.parent = ret, ret } }, node } }, {}, "/proc/self/fd") }, createStandardStreams: function () { Module.stdin ? FS.createDevice("/dev", "stdin", Module.stdin) : FS.symlink("/dev/tty", "/dev/stdin"), Module.stdout ? FS.createDevice("/dev", "stdout", null, Module.stdout) : FS.symlink("/dev/tty", "/dev/stdout"), Module.stderr ? FS.createDevice("/dev", "stderr", null, Module.stderr) : FS.symlink("/dev/tty1", "/dev/stderr"); FS.open("/dev/stdin", "r"), FS.open("/dev/stdout", "w"), FS.open("/dev/stderr", "w") }, ensureErrnoError: function () { FS.ErrnoError || (FS.ErrnoError = function ErrnoError(errno, node) { this.node = node, this.setErrno = function (errno) { this.errno = errno }, this.setErrno(errno), this.message = "FS error", this.stack && Object.defineProperty(this, "stack", { value: (new Error).stack, writable: !0 }) }, FS.ErrnoError.prototype = new Error, FS.ErrnoError.prototype.constructor = FS.ErrnoError, [2].forEach((function (code) { FS.genericErrors[code] = new FS.ErrnoError(code), FS.genericErrors[code].stack = "<generic error, no stack>" }))) }, staticInit: function () { FS.ensureErrnoError(), FS.nameTable = new Array(4096), FS.mount(MEMFS, {}, "/"), FS.createDefaultDirectories(), FS.createDefaultDevices(), FS.createSpecialDirectories(), FS.filesystems = { MEMFS: MEMFS, IDBFS: IDBFS, WORKERFS: WORKERFS } }, init: function (input, output, error) { FS.init.initialized = !0, FS.ensureErrnoError(), Module.stdin = input || Module.stdin, Module.stdout = output || Module.stdout, Module.stderr = error || Module.stderr, FS.createStandardStreams() }, quit: function () { FS.init.initialized = !1; var fflush = Module._fflush; fflush && fflush(0); for (var i = 0; i < FS.streams.length; i++) { var stream = FS.streams[i]; stream && FS.close(stream) } }, getMode: function (canRead, canWrite) { var mode = 0; return canRead && (mode |= 365), canWrite && (mode |= 146), mode }, joinPath: function (parts, forceRelative) { var path = PATH.join.apply(null, parts); return forceRelative && "/" == path[0] && (path = path.substr(1)), path }, absolutePath: function (relative, base) { return PATH.resolve(base, relative) }, standardizePath: function (path) { return PATH.normalize(path) }, findObject: function (path, dontResolveLastLink) { var ret = FS.analyzePath(path, dontResolveLastLink); return ret.exists ? ret.object : (___setErrNo(ret.error), null) }, analyzePath: function (path, dontResolveLastLink) { try { path = (lookup = FS.lookupPath(path, { follow: !dontResolveLastLink })).path } catch (e) { } var ret = { isRoot: !1, exists: !1, error: 0, name: null, path: null, object: null, parentExists: !1, parentPath: null, parentObject: null }; try { var lookup = FS.lookupPath(path, { parent: !0 }); ret.parentExists = !0, ret.parentPath = lookup.path, ret.parentObject = lookup.node, ret.name = PATH.basename(path), lookup = FS.lookupPath(path, { follow: !dontResolveLastLink }), ret.exists = !0, ret.path = lookup.path, ret.object = lookup.node, ret.name = lookup.node.name, ret.isRoot = "/" === lookup.path } catch (e) { ret.error = e.errno } return ret }, createFolder: function (parent, name, canRead, canWrite) { var path = PATH.join2("string" == typeof parent ? parent : FS.getPath(parent), name), mode = FS.getMode(canRead, canWrite); return FS.mkdir(path, mode) }, createPath: function (parent, path, canRead, canWrite) { parent = "string" == typeof parent ? parent : FS.getPath(parent); for (var parts = path.split("/").reverse(); parts.length;) { var part = parts.pop(); if (part) { var current = PATH.join2(parent, part); try { FS.mkdir(current) } catch (e) { } parent = current } } return current }, createFile: function (parent, name, properties, canRead, canWrite) { var path = PATH.join2("string" == typeof parent ? parent : FS.getPath(parent), name), mode = FS.getMode(canRead, canWrite); return FS.create(path, mode) }, createDataFile: function (parent, name, data, canRead, canWrite, canOwn) { var path = name ? PATH.join2("string" == typeof parent ? parent : FS.getPath(parent), name) : parent, mode = FS.getMode(canRead, canWrite), node = FS.create(path, mode); if (data) { if ("string" == typeof data) { for (var arr = new Array(data.length), i = 0, len = data.length; i < len; ++i)arr[i] = data.charCodeAt(i); data = arr } FS.chmod(node, 146 | mode); var stream = FS.open(node, "w"); FS.write(stream, data, 0, data.length, 0, canOwn), FS.close(stream), FS.chmod(node, mode) } return node }, createDevice: function (parent, name, input, output) { var path = PATH.join2("string" == typeof parent ? parent : FS.getPath(parent), name), mode = FS.getMode(!!input, !!output); FS.createDevice.major || (FS.createDevice.major = 64); var dev = FS.makedev(FS.createDevice.major++, 0); return FS.registerDevice(dev, { open: function (stream) { stream.seekable = !1 }, close: function (stream) { output && output.buffer && output.buffer.length && output(10) }, read: function (stream, buffer, offset, length, pos) { for (var bytesRead = 0, i = 0; i < length; i++) { var result; try { result = input() } catch (e) { throw new FS.ErrnoError(5) } if (void 0 === result && 0 === bytesRead) throw new FS.ErrnoError(11); if (null == result) break; bytesRead++, buffer[offset + i] = result } return bytesRead && (stream.node.timestamp = Date.now()), bytesRead }, write: function (stream, buffer, offset, length, pos) { for (var i = 0; i < length; i++)try { output(buffer[offset + i]) } catch (e) { throw new FS.ErrnoError(5) } return length && (stream.node.timestamp = Date.now()), i } }), FS.mkdev(path, mode, dev) }, createLink: function (parent, name, target, canRead, canWrite) { var path = PATH.join2("string" == typeof parent ? parent : FS.getPath(parent), name); return FS.symlink(target, path) }, forceLoadFile: function (obj) { if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return !0; var success = !0; if ("undefined" != typeof XMLHttpRequest) throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread."); if (!Module.read) throw new Error("Cannot load without read() or XMLHttpRequest."); try { obj.contents = intArrayFromString(Module.read(obj.url), !0), obj.usedBytes = obj.contents.length } catch (e) { success = !1 } return success || ___setErrNo(5), success }, createLazyFile: function (parent, name, url, canRead, canWrite) { function LazyUint8Array() { this.lengthKnown = !1, this.chunks = [] } if (LazyUint8Array.prototype.get = function LazyUint8Array_get(idx) { if (!(idx > this.length - 1 || idx < 0)) { var chunkOffset = idx % this.chunkSize, chunkNum = idx / this.chunkSize | 0; return this.getter(chunkNum)[chunkOffset] } }, LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) { this.getter = getter }, LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() { var xhr = new XMLHttpRequest; if (xhr.open("HEAD", url, !1), xhr.send(null), !(xhr.status >= 200 && xhr.status < 300 || 304 === xhr.status)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); var header, datalength = Number(xhr.getResponseHeader("Content-length")), hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && "bytes" === header, usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && "gzip" === header, chunkSize = 1048576; hasByteServing || (chunkSize = datalength); var lazyArray = this; lazyArray.setDataGetter((function (chunkNum) { var start = chunkNum * chunkSize, end = (chunkNum + 1) * chunkSize - 1; if (end = Math.min(end, datalength - 1), void 0 === lazyArray.chunks[chunkNum] && (lazyArray.chunks[chunkNum] = function (from, to) { if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!"); if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!"); var xhr = new XMLHttpRequest; if (xhr.open("GET", url, !1), datalength !== chunkSize && xhr.setRequestHeader("Range", "bytes=" + from + "-" + to), "undefined" != typeof Uint8Array && (xhr.responseType = "arraybuffer"), xhr.overrideMimeType && xhr.overrideMimeType("text/plain; charset=x-user-defined"), xhr.send(null), !(xhr.status >= 200 && xhr.status < 300 || 304 === xhr.status)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status); return void 0 !== xhr.response ? new Uint8Array(xhr.response || []) : intArrayFromString(xhr.responseText || "", !0) }(start, end)), void 0 === lazyArray.chunks[chunkNum]) throw new Error("doXHR failed!"); return lazyArray.chunks[chunkNum] })), !usesGzip && datalength || (chunkSize = datalength = 1, datalength = this.getter(0).length, chunkSize = datalength), this._length = datalength, this._chunkSize = chunkSize, this.lengthKnown = !0 }, "undefined" != typeof XMLHttpRequest) { if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc"; var lazyArray = new LazyUint8Array; Object.defineProperties(lazyArray, { length: { get: function () { return this.lengthKnown || this.cacheLength(), this._length } }, chunkSize: { get: function () { return this.lengthKnown || this.cacheLength(), this._chunkSize } } }); var properties = { isDevice: !1, contents: lazyArray } } else properties = { isDevice: !1, url: url }; var node = FS.createFile(parent, name, properties, canRead, canWrite); properties.contents ? node.contents = properties.contents : properties.url && (node.contents = null, node.url = properties.url), Object.defineProperties(node, { usedBytes: { get: function () { return this.contents.length } } }); var stream_ops = {}; return Object.keys(node.stream_ops).forEach((function (key) { var fn = node.stream_ops[key]; stream_ops[key] = function forceLoadLazyFile() { if (!FS.forceLoadFile(node)) throw new FS.ErrnoError(5); return fn.apply(null, arguments) } })), stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) { if (!FS.forceLoadFile(node)) throw new FS.ErrnoError(5); var contents = stream.node.contents; if (position >= contents.length) return 0; var size = Math.min(contents.length - position, length); if (contents.slice) for (var i = 0; i < size; i++)buffer[offset + i] = contents[position + i]; else for (i = 0; i < size; i++)buffer[offset + i] = contents.get(position + i); return size }, node.stream_ops = stream_ops, node }, createPreloadedFile: function (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) { Browser.init(); var fullname = name ? PATH.resolve(PATH.join2(parent, name)) : parent, dep = getUniqueRunDependency("cp " + fullname); function processData(byteArray) { function finish(byteArray) { preFinish && preFinish(), dontCreateFile || FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn), onload && onload(), removeRunDependency(dep) } var handled = !1; Module.preloadPlugins.forEach((function (plugin) { handled || plugin.canHandle(fullname) && (plugin.handle(byteArray, fullname, finish, (function () { onerror && onerror(), removeRunDependency(dep) })), handled = !0) })), handled || finish(byteArray) } addRunDependency(dep), "string" == typeof url ? Browser.asyncLoad(url, (function (byteArray) { processData(byteArray) }), onerror) : processData(url) }, indexedDB: function () { return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB }, DB_NAME: function () { return "EM_FS_" + window.location.pathname }, DB_VERSION: 20, DB_STORE_NAME: "FILE_DATA", saveFilesToDB: function (paths, onload, onerror) { onload = onload || function () { }, onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) } openRequest.onupgradeneeded = function openRequest_onupgradeneeded() { openRequest.result.createObjectStore(FS.DB_STORE_NAME) }, openRequest.onsuccess = function openRequest_onsuccess() { var transaction = openRequest.result.transaction([FS.DB_STORE_NAME], "readwrite"), files = transaction.objectStore(FS.DB_STORE_NAME), ok = 0, fail = 0, total = paths.length; function finish() { 0 == fail ? onload() : onerror() } paths.forEach((function (path) { var putRequest = files.put(FS.analyzePath(path).object.contents, path); putRequest.onsuccess = function putRequest_onsuccess() { ++ok + fail == total && finish() }, putRequest.onerror = function putRequest_onerror() { fail++, ok + fail == total && finish() } })), transaction.onerror = onerror }, openRequest.onerror = onerror }, loadFilesFromDB: function (paths, onload, onerror) { onload = onload || function () { }, onerror = onerror || function () { }; var indexedDB = FS.indexedDB(); try { var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION) } catch (e) { return onerror(e) } openRequest.onupgradeneeded = onerror, openRequest.onsuccess = function openRequest_onsuccess() { var db = openRequest.result; try { var transaction = db.transaction([FS.DB_STORE_NAME], "readonly") } catch (e) { return void onerror(e) } var files = transaction.objectStore(FS.DB_STORE_NAME), ok = 0, fail = 0, total = paths.length; function finish() { 0 == fail ? onload() : onerror() } paths.forEach((function (path) { var getRequest = files.get(path); getRequest.onsuccess = function getRequest_onsuccess() { FS.analyzePath(path).exists && FS.unlink(path), FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, !0, !0, !0), ++ok + fail == total && finish() }, getRequest.onerror = function getRequest_onerror() { fail++, ok + fail == total && finish() } })), transaction.onerror = onerror }, openRequest.onerror = onerror } }, ERRNO_CODES = { EPERM: 1, ENOENT: 2, ESRCH: 3, EINTR: 4, EIO: 5, ENXIO: 6, E2BIG: 7, ENOEXEC: 8, EBADF: 9, ECHILD: 10, EAGAIN: 11, EWOULDBLOCK: 11, ENOMEM: 12, EACCES: 13, EFAULT: 14, ENOTBLK: 15, EBUSY: 16, EEXIST: 17, EXDEV: 18, ENODEV: 19, ENOTDIR: 20, EISDIR: 21, EINVAL: 22, ENFILE: 23, EMFILE: 24, ENOTTY: 25, ETXTBSY: 26, EFBIG: 27, ENOSPC: 28, ESPIPE: 29, EROFS: 30, EMLINK: 31, EPIPE: 32, EDOM: 33, ERANGE: 34, ENOMSG: 42, EIDRM: 43, ECHRNG: 44, EL2NSYNC: 45, EL3HLT: 46, EL3RST: 47, ELNRNG: 48, EUNATCH: 49, ENOCSI: 50, EL2HLT: 51, EDEADLK: 35, ENOLCK: 37, EBADE: 52, EBADR: 53, EXFULL: 54, ENOANO: 55, EBADRQC: 56, EBADSLT: 57, EDEADLOCK: 35, EBFONT: 59, ENOSTR: 60, ENODATA: 61, ETIME: 62, ENOSR: 63, ENONET: 64, ENOPKG: 65, EREMOTE: 66, ENOLINK: 67, EADV: 68, ESRMNT: 69, ECOMM: 70, EPROTO: 71, EMULTIHOP: 72, EDOTDOT: 73, EBADMSG: 74, ENOTUNIQ: 76, EBADFD: 77, EREMCHG: 78, ELIBACC: 79, ELIBBAD: 80, ELIBSCN: 81, ELIBMAX: 82, ELIBEXEC: 83, ENOSYS: 38, ENOTEMPTY: 39, ENAMETOOLONG: 36, ELOOP: 40, EOPNOTSUPP: 95, EPFNOSUPPORT: 96, ECONNRESET: 104, ENOBUFS: 105, EAFNOSUPPORT: 97, EPROTOTYPE: 91, ENOTSOCK: 88, ENOPROTOOPT: 92, ESHUTDOWN: 108, ECONNREFUSED: 111, EADDRINUSE: 98, ECONNABORTED: 103, ENETUNREACH: 101, ENETDOWN: 100, ETIMEDOUT: 110, EHOSTDOWN: 112, EHOSTUNREACH: 113, EINPROGRESS: 115, EALREADY: 114, EDESTADDRREQ: 89, EMSGSIZE: 90, EPROTONOSUPPORT: 93, ESOCKTNOSUPPORT: 94, EADDRNOTAVAIL: 99, ENETRESET: 102, EISCONN: 106, ENOTCONN: 107, ETOOMANYREFS: 109, EUSERS: 87, EDQUOT: 122, ESTALE: 116, ENOTSUP: 95, ENOMEDIUM: 123, EILSEQ: 84, EOVERFLOW: 75, ECANCELED: 125, ENOTRECOVERABLE: 131, EOWNERDEAD: 130, ESTRPIPE: 86 }, SYSCALLS = { DEFAULT_POLLMASK: 5, mappings: {}, umask: 511, calculateAt: function (dirfd, path) { if ("/" !== path[0]) { var dir; if (-100 === dirfd) dir = FS.cwd(); else { var dirstream = FS.getStream(dirfd); if (!dirstream) throw new FS.ErrnoError(ERRNO_CODES.EBADF); dir = dirstream.path } path = PATH.join2(dir, path) } return path }, doStat: function (func, path, buf) { try { var stat = func(path) } catch (e) { if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) return -ERRNO_CODES.ENOTDIR; throw e } return HEAP32[buf >> 2] = stat.dev, HEAP32[buf + 4 >> 2] = 0, HEAP32[buf + 8 >> 2] = stat.ino, HEAP32[buf + 12 >> 2] = stat.mode, HEAP32[buf + 16 >> 2] = stat.nlink, HEAP32[buf + 20 >> 2] = stat.uid, HEAP32[buf + 24 >> 2] = stat.gid, HEAP32[buf + 28 >> 2] = stat.rdev, HEAP32[buf + 32 >> 2] = 0, tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1], HEAP32[buf + 48 >> 2] = 4096, HEAP32[buf + 52 >> 2] = stat.blocks, HEAP32[buf + 56 >> 2] = stat.atime.getTime() / 1e3 | 0, HEAP32[buf + 60 >> 2] = 0, HEAP32[buf + 64 >> 2] = stat.mtime.getTime() / 1e3 | 0, HEAP32[buf + 68 >> 2] = 0, HEAP32[buf + 72 >> 2] = stat.ctime.getTime() / 1e3 | 0, HEAP32[buf + 76 >> 2] = 0, tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 80 >> 2] = tempI64[0], HEAP32[buf + 84 >> 2] = tempI64[1], 0 }, doMsync: function (addr, stream, len, flags) { var buffer = new Uint8Array(HEAPU8.subarray(addr, addr + len)); FS.msync(stream, buffer, 0, len, flags) }, doMkdir: function (path, mode) { return "/" === (path = PATH.normalize(path))[path.length - 1] && (path = path.substr(0, path.length - 1)), FS.mkdir(path, mode, 0), 0 }, doMknod: function (path, mode, dev) { switch (61440 & mode) { case 32768: case 8192: case 24576: case 4096: case 49152: break; default: return -ERRNO_CODES.EINVAL }return FS.mknod(path, mode, dev), 0 }, doReadlink: function (path, buf, bufsize) { if (bufsize <= 0) return -ERRNO_CODES.EINVAL; var ret = FS.readlink(path), len = Math.min(bufsize, lengthBytesUTF8(ret)), endChar = HEAP8[buf + len]; return stringToUTF8(ret, buf, bufsize + 1), HEAP8[buf + len] = endChar, len }, doAccess: function (path, amode) { if (-8 & amode) return -ERRNO_CODES.EINVAL; var node; node = FS.lookupPath(path, { follow: !0 }).node; var perms = ""; return 4 & amode && (perms += "r"), 2 & amode && (perms += "w"), 1 & amode && (perms += "x"), perms && FS.nodePermissions(node, perms) ? -ERRNO_CODES.EACCES : 0 }, doDup: function (path, flags, suggestFD) { var suggest = FS.getStream(suggestFD); return suggest && FS.close(suggest), FS.open(path, flags, 0, suggestFD, suggestFD).fd }, doReadv: function (stream, iov, iovcnt, offset) { for (var ret = 0, i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + 8 * i >> 2], len = HEAP32[iov + (8 * i + 4) >> 2], curr = FS.read(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; if (ret += curr, curr < len) break } return ret }, doWritev: function (stream, iov, iovcnt, offset) { for (var ret = 0, i = 0; i < iovcnt; i++) { var ptr = HEAP32[iov + 8 * i >> 2], len = HEAP32[iov + (8 * i + 4) >> 2], curr = FS.write(stream, HEAP8, ptr, len, offset); if (curr < 0) return -1; ret += curr } return ret }, varargs: 0, get: function (varargs) { return SYSCALLS.varargs += 4, HEAP32[SYSCALLS.varargs - 4 >> 2] }, getStr: function () { return UTF8ToString(SYSCALLS.get()) }, getStreamFromFD: function () { var stream = FS.getStream(SYSCALLS.get()); if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF); return stream }, getSocketFromFD: function () { var socket = SOCKFS.getSocket(SYSCALLS.get()); if (!socket) throw new FS.ErrnoError(ERRNO_CODES.EBADF); return socket }, getSocketAddress: function (allowNull) { var addrp = SYSCALLS.get(), addrlen = SYSCALLS.get(); if (allowNull && 0 === addrp) return null; var info = __read_sockaddr(addrp, addrlen); if (info.errno) throw new FS.ErrnoError(info.errno); return info.addr = DNS.lookup_addr(info.addr) || info.addr, info }, get64: function () { var low = SYSCALLS.get(); SYSCALLS.get(); return low }, getZero: function () { SYSCALLS.get() } }; function ___syscall10(which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(); return FS.unlink(path), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall140(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get(); if (!(-1 == offset_high && offset_low < 0 || 0 == offset_high && offset_low >= 0)) return -ERRNO_CODES.EOVERFLOW; var offset = offset_low; return FS.llseek(stream, offset, whence), tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[result >> 2] = tempI64[0], HEAP32[result + 4 >> 2] = tempI64[1], stream.getdents && 0 === offset && 0 === whence && (stream.getdents = null), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall142(which, varargs) { SYSCALLS.varargs = varargs; try { for (var nfds = SYSCALLS.get(), readfds = SYSCALLS.get(), writefds = SYSCALLS.get(), exceptfds = SYSCALLS.get(), total = (SYSCALLS.get(), 0), srcReadLow = readfds ? HEAP32[readfds >> 2] : 0, srcReadHigh = readfds ? HEAP32[readfds + 4 >> 2] : 0, srcWriteLow = writefds ? HEAP32[writefds >> 2] : 0, srcWriteHigh = writefds ? HEAP32[writefds + 4 >> 2] : 0, srcExceptLow = exceptfds ? HEAP32[exceptfds >> 2] : 0, srcExceptHigh = exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0, dstReadLow = 0, dstReadHigh = 0, dstWriteLow = 0, dstWriteHigh = 0, dstExceptLow = 0, dstExceptHigh = 0, allLow = (readfds ? HEAP32[readfds >> 2] : 0) | (writefds ? HEAP32[writefds >> 2] : 0) | (exceptfds ? HEAP32[exceptfds >> 2] : 0), allHigh = (readfds ? HEAP32[readfds + 4 >> 2] : 0) | (writefds ? HEAP32[writefds + 4 >> 2] : 0) | (exceptfds ? HEAP32[exceptfds + 4 >> 2] : 0), check = function (fd, low, high, val) { return fd < 32 ? low & val : high & val }, fd = 0; fd < nfds; fd++) { var mask = 1 << fd % 32; if (check(fd, allLow, allHigh, mask)) { var stream = FS.getStream(fd); if (!stream) throw new FS.ErrnoError(ERRNO_CODES.EBADF); var flags = SYSCALLS.DEFAULT_POLLMASK; stream.stream_ops.poll && (flags = stream.stream_ops.poll(stream)), 1 & flags && check(fd, srcReadLow, srcReadHigh, mask) && (fd < 32 ? dstReadLow |= mask : dstReadHigh |= mask, total++), 4 & flags && check(fd, srcWriteLow, srcWriteHigh, mask) && (fd < 32 ? dstWriteLow |= mask : dstWriteHigh |= mask, total++), 2 & flags && check(fd, srcExceptLow, srcExceptHigh, mask) && (fd < 32 ? dstExceptLow |= mask : dstExceptHigh |= mask, total++) } } return readfds && (HEAP32[readfds >> 2] = dstReadLow, HEAP32[readfds + 4 >> 2] = dstReadHigh), writefds && (HEAP32[writefds >> 2] = dstWriteLow, HEAP32[writefds + 4 >> 2] = dstWriteHigh), exceptfds && (HEAP32[exceptfds >> 2] = dstExceptLow, HEAP32[exceptfds + 4 >> 2] = dstExceptHigh), total } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall145(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get(); return SYSCALLS.doReadv(stream, iov, iovcnt) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall146(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get(); return SYSCALLS.doWritev(stream, iov, iovcnt) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall195(which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(), buf = SYSCALLS.get(); return SYSCALLS.doStat(FS.stat, path, buf) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall196(which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(), buf = SYSCALLS.get(); return SYSCALLS.doStat(FS.lstat, path, buf) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall197(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(); return SYSCALLS.doStat(FS.stat, stream.path, buf) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall220(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), dirp = SYSCALLS.get(), count = SYSCALLS.get(); stream.getdents || (stream.getdents = FS.readdir(stream.path)); for (var pos = 0; stream.getdents.length > 0 && pos + 280 <= count;) { var id, type, name = stream.getdents.pop(); if ("." === name[0]) id = 1, type = 4; else { var child = FS.lookupNode(stream.node, name); id = child.id, type = FS.isChrdev(child.mode) ? 2 : FS.isDir(child.mode) ? 4 : FS.isLink(child.mode) ? 10 : 8 } tempI64 = [id >>> 0, (tempDouble = id, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos >> 2] = tempI64[0], HEAP32[dirp + pos + 4 >> 2] = tempI64[1], tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math_abs(tempDouble) >= 1 ? tempDouble > 0 ? (0 | Math_min(+Math_floor(tempDouble / 4294967296), 4294967295)) >>> 0 : ~~+Math_ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[dirp + pos + 8 >> 2] = tempI64[0], HEAP32[dirp + pos + 12 >> 2] = tempI64[1], HEAP16[dirp + pos + 16 >> 1] = 280, HEAP8[dirp + pos + 18 >> 0] = type, stringToUTF8(name, dirp + pos + 19, 256), pos += 280 } return pos } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall221(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); switch (SYSCALLS.get()) { case 0: return (arg = SYSCALLS.get()) < 0 ? -ERRNO_CODES.EINVAL : FS.open(stream.path, stream.flags, 0, arg).fd; case 1: case 2: return 0; case 3: return stream.flags; case 4: var arg = SYSCALLS.get(); return stream.flags |= arg, 0; case 12: arg = SYSCALLS.get(); return HEAP16[arg + 0 >> 1] = 2, 0; case 13: case 14: return 0; case 16: case 8: return -ERRNO_CODES.EINVAL; case 9: return ___setErrNo(ERRNO_CODES.EINVAL), -1; default: return -ERRNO_CODES.EINVAL } } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall3(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get(); return FS.read(stream, HEAP8, buf, count) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall33(which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(), amode = SYSCALLS.get(); return SYSCALLS.doAccess(path, amode) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall340(which, varargs) { SYSCALLS.varargs = varargs; try { SYSCALLS.get(), SYSCALLS.get(), SYSCALLS.get(); var old_limit = SYSCALLS.get(); return old_limit && (HEAP32[old_limit >> 2] = -1, HEAP32[old_limit + 4 >> 2] = -1, HEAP32[old_limit + 8 >> 2] = -1, HEAP32[old_limit + 12 >> 2] = -1), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall38(which, varargs) { SYSCALLS.varargs = varargs; try { var old_path = SYSCALLS.getStr(), new_path = SYSCALLS.getStr(); return FS.rename(old_path, new_path), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall4(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), buf = SYSCALLS.get(), count = SYSCALLS.get(); return FS.write(stream, HEAP8, buf, count) } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall40(which, varargs) { SYSCALLS.varargs = varargs; try { var path = SYSCALLS.getStr(); return FS.rmdir(path), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall5(which, varargs) { SYSCALLS.varargs = varargs; try { var pathname = SYSCALLS.getStr(), flags = SYSCALLS.get(), mode = SYSCALLS.get(); return FS.open(pathname, flags, mode).fd } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall54(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(), op = SYSCALLS.get(); switch (op) { case 21509: case 21505: return stream.tty ? 0 : -ERRNO_CODES.ENOTTY; case 21510: case 21511: case 21512: case 21506: case 21507: case 21508: return stream.tty ? 0 : -ERRNO_CODES.ENOTTY; case 21519: if (!stream.tty) return -ERRNO_CODES.ENOTTY; var argp = SYSCALLS.get(); return HEAP32[argp >> 2] = 0, 0; case 21520: return stream.tty ? -ERRNO_CODES.EINVAL : -ERRNO_CODES.ENOTTY; case 21531: argp = SYSCALLS.get(); return FS.ioctl(stream, op, argp); case 21523: case 21524: return stream.tty ? 0 : -ERRNO_CODES.ENOTTY; default: abort("bad ioctl syscall " + op) } } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall6(which, varargs) { SYSCALLS.varargs = varargs; try { var stream = SYSCALLS.getStreamFromFD(); return FS.close(stream), 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall75(which, varargs) { SYSCALLS.varargs = varargs; try { return 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___syscall77(which, varargs) { SYSCALLS.varargs = varargs; try { SYSCALLS.get(); var usage = SYSCALLS.get(); return _memset(usage, 0, 136), HEAP32[usage >> 2] = 1, HEAP32[usage + 4 >> 2] = 2, HEAP32[usage + 8 >> 2] = 3, HEAP32[usage + 12 >> 2] = 4, 0 } catch (e) { return void 0 !== FS && e instanceof FS.ErrnoError || abort(e), -e.errno } } function ___unlock() { } function _abort() { Module.abort() } function _clock() { return void 0 === _clock.start && (_clock.start = Date.now()), 1e3 * (Date.now() - _clock.start) | 0 } function _emscripten_get_now() { abort() } function _emscripten_get_now_is_monotonic() { return "object" == typeof performance && performance && "function" == typeof performance.now } function _clock_gettime(clk_id, tp) { var now; if (0 === clk_id) now = Date.now(); else { if (1 !== clk_id || !_emscripten_get_now_is_monotonic()) return ___setErrNo(22), -1; now = _emscripten_get_now() } return HEAP32[tp >> 2] = now / 1e3 | 0, HEAP32[tp + 4 >> 2] = now % 1e3 * 1e3 * 1e3 | 0, 0 } function _emscripten_get_heap_size() { return HEAP8.length } function abortOnCannotGrowMemory(requestedSize) { abort("OOM") } function emscripten_realloc_buffer(size) { size = alignUp(size, 65536); var oldSize = buffer.byteLength; try { return -1 !== wasmMemory.grow((size - oldSize) / 65536) && (buffer = wasmMemory.buffer, !0) } catch (e) { return !1 } } function _emscripten_resize_heap(requestedSize) { var oldSize = _emscripten_get_heap_size(); if (requestedSize > 2147418112) return !1; for (var newSize = Math.max(oldSize, 16777216); newSize < requestedSize;)newSize = newSize <= 536870912 ? alignUp(2 * newSize, 65536) : Math.min(alignUp((3 * newSize + 2147483648) / 4, 65536), 2147418112); return !!emscripten_realloc_buffer(newSize) && (updateGlobalBufferViews(), !0) } function _exit(status) { exit(status) } var _fabs = Math_abs; function _getenv(name) { return 0 === name ? 0 : (name = UTF8ToString(name), ENV.hasOwnProperty(name) ? (_getenv.ret && _free(_getenv.ret), _getenv.ret = allocateUTF8(ENV[name]), _getenv.ret) : 0) } function _gettimeofday(ptr) { var now = Date.now(); return HEAP32[ptr >> 2] = now / 1e3 | 0, HEAP32[ptr + 4 >> 2] = now % 1e3 * 1e3 | 0, 0 } var ___tm_current = 2340640, ___tm_timezone = (stringToUTF8("GMT", 2340688, 4), 2340688); function _gmtime_r(time, tmPtr) { var date = new Date(1e3 * HEAP32[time >> 2]); HEAP32[tmPtr >> 2] = date.getUTCSeconds(), HEAP32[tmPtr + 4 >> 2] = date.getUTCMinutes(), HEAP32[tmPtr + 8 >> 2] = date.getUTCHours(), HEAP32[tmPtr + 12 >> 2] = date.getUTCDate(), HEAP32[tmPtr + 16 >> 2] = date.getUTCMonth(), HEAP32[tmPtr + 20 >> 2] = date.getUTCFullYear() - 1900, HEAP32[tmPtr + 24 >> 2] = date.getUTCDay(), HEAP32[tmPtr + 36 >> 2] = 0, HEAP32[tmPtr + 32 >> 2] = 0; var start = Date.UTC(date.getUTCFullYear(), 0, 1, 0, 0, 0, 0), yday = (date.getTime() - start) / 864e5 | 0; return HEAP32[tmPtr + 28 >> 2] = yday, HEAP32[tmPtr + 40 >> 2] = ___tm_timezone, tmPtr } function _gmtime(time) { return _gmtime_r(time, ___tm_current) } var _llvm_cos_f64 = Math_cos; function _llvm_exp2_f32(x) { return Math.pow(2, x) } function _llvm_exp2_f64(a0) { return _llvm_exp2_f32(a0) } function _llvm_log10_f32(x) { return Math.log(x) / Math.LN10 } function _llvm_log10_f64(a0) { return _llvm_log10_f32(a0) } function _llvm_log2_f32(x) { return Math.log(x) / Math.LN2 } var _llvm_sin_f64 = Math_sin; function _llvm_stackrestore(p) { var self = _llvm_stacksave, ret = self.LLVM_SAVEDSTACKS[p]; self.LLVM_SAVEDSTACKS.splice(p, 1), stackRestore(ret) } function _llvm_stacksave() { var self = _llvm_stacksave; return self.LLVM_SAVEDSTACKS || (self.LLVM_SAVEDSTACKS = []), self.LLVM_SAVEDSTACKS.push(stackSave()), self.LLVM_SAVEDSTACKS.length - 1 } var _llvm_trunc_f32 = Math_trunc, _llvm_trunc_f64 = Math_trunc; function _tzset() { if (!_tzset.called) { _tzset.called = !0, HEAP32[__get_timezone() >> 2] = 60 * (new Date).getTimezoneOffset(); var winter = new Date(2e3, 0, 1), summer = new Date(2e3, 6, 1); HEAP32[__get_daylight() >> 2] = Number(winter.getTimezoneOffset() != summer.getTimezoneOffset()); var winterName = extractZone(winter), summerName = extractZone(summer), winterNamePtr = allocate(intArrayFromString(winterName), "i8", ALLOC_NORMAL), summerNamePtr = allocate(intArrayFromString(summerName), "i8", ALLOC_NORMAL); summer.getTimezoneOffset() < winter.getTimezoneOffset() ? (HEAP32[__get_tzname() >> 2] = winterNamePtr, HEAP32[__get_tzname() + 4 >> 2] = summerNamePtr) : (HEAP32[__get_tzname() >> 2] = summerNamePtr, HEAP32[__get_tzname() + 4 >> 2] = winterNamePtr) } function extractZone(date) { var match = date.toTimeString().match(/\(([A-Za-z ]+)\)$/); return match ? match[1] : "GMT" } } function _localtime_r(time, tmPtr) { _tzset(); var date = new Date(1e3 * HEAP32[time >> 2]); HEAP32[tmPtr >> 2] = date.getSeconds(), HEAP32[tmPtr + 4 >> 2] = date.getMinutes(), HEAP32[tmPtr + 8 >> 2] = date.getHours(), HEAP32[tmPtr + 12 >> 2] = date.getDate(), HEAP32[tmPtr + 16 >> 2] = date.getMonth(), HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900, HEAP32[tmPtr + 24 >> 2] = date.getDay(); var start = new Date(date.getFullYear(), 0, 1), yday = (date.getTime() - start.getTime()) / 864e5 | 0; HEAP32[tmPtr + 28 >> 2] = yday, HEAP32[tmPtr + 36 >> 2] = -60 * date.getTimezoneOffset(); var summerOffset = new Date(2e3, 6, 1).getTimezoneOffset(), winterOffset = start.getTimezoneOffset(), dst = 0 | (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)); HEAP32[tmPtr + 32 >> 2] = dst; var zonePtr = HEAP32[__get_tzname() + (dst ? 4 : 0) >> 2]; return HEAP32[tmPtr + 40 >> 2] = zonePtr, tmPtr } function _localtime(time) { return _localtime_r(time, ___tm_current) } function _emscripten_memcpy_big(dest, src, num) { HEAPU8.set(HEAPU8.subarray(src, src + num), dest) } function _mktime(tmPtr) { _tzset(); var date = new Date(HEAP32[tmPtr + 20 >> 2] + 1900, HEAP32[tmPtr + 16 >> 2], HEAP32[tmPtr + 12 >> 2], HEAP32[tmPtr + 8 >> 2], HEAP32[tmPtr + 4 >> 2], HEAP32[tmPtr >> 2], 0), dst = HEAP32[tmPtr + 32 >> 2], guessedOffset = date.getTimezoneOffset(), start = new Date(date.getFullYear(), 0, 1), summerOffset = new Date(2e3, 6, 1).getTimezoneOffset(), winterOffset = start.getTimezoneOffset(), dstOffset = Math.min(winterOffset, summerOffset); if (dst < 0) HEAP32[tmPtr + 32 >> 2] = Number(summerOffset != winterOffset && dstOffset == guessedOffset); else if (dst > 0 != (dstOffset == guessedOffset)) { var nonDstOffset = Math.max(winterOffset, summerOffset), trueOffset = dst > 0 ? dstOffset : nonDstOffset; date.setTime(date.getTime() + 6e4 * (trueOffset - guessedOffset)) } HEAP32[tmPtr + 24 >> 2] = date.getDay(); var yday = (date.getTime() - start.getTime()) / 864e5 | 0; return HEAP32[tmPtr + 28 >> 2] = yday, date.getTime() / 1e3 | 0 } function _usleep(useconds) { var msec = useconds / 1e3; if ((ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && self.performance && self.performance.now) for (var start = self.performance.now(); self.performance.now() - start < msec;); else for (start = Date.now(); Date.now() - start < msec;); return 0 } function _nanosleep(rqtp, rmtp) { var seconds = HEAP32[rqtp >> 2], nanoseconds = HEAP32[rqtp + 4 >> 2]; return 0 !== rmtp && (HEAP32[rmtp >> 2] = 0, HEAP32[rmtp + 4 >> 2] = 0), _usleep(1e6 * seconds + nanoseconds / 1e3) } var __sigalrm_handler = 0; function _signal(sig, func) { return 14 == sig && (__sigalrm_handler = func), 0 } function __isLeapYear(year) { return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0) } function __arraySum(array, index) { for (var sum = 0, i = 0; i <= index; sum += array[i++]); return sum } var __MONTH_DAYS_LEAP = [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31], __MONTH_DAYS_REGULAR = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]; function __addDays(date, days) { for (var newDate = new Date(date.getTime()); days > 0;) { var leap = __isLeapYear(newDate.getFullYear()), currentMonth = newDate.getMonth(), daysInCurrentMonth = (leap ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR)[currentMonth]; if (!(days > daysInCurrentMonth - newDate.getDate())) return newDate.setDate(newDate.getDate() + days), newDate; days -= daysInCurrentMonth - newDate.getDate() + 1, newDate.setDate(1), currentMonth < 11 ? newDate.setMonth(currentMonth + 1) : (newDate.setMonth(0), newDate.setFullYear(newDate.getFullYear() + 1)) } return newDate } function _strftime(s, maxsize, format, tm) { var tm_zone = HEAP32[tm + 40 >> 2], date = { tm_sec: HEAP32[tm >> 2], tm_min: HEAP32[tm + 4 >> 2], tm_hour: HEAP32[tm + 8 >> 2], tm_mday: HEAP32[tm + 12 >> 2], tm_mon: HEAP32[tm + 16 >> 2], tm_year: HEAP32[tm + 20 >> 2], tm_wday: HEAP32[tm + 24 >> 2], tm_yday: HEAP32[tm + 28 >> 2], tm_isdst: HEAP32[tm + 32 >> 2], tm_gmtoff: HEAP32[tm + 36 >> 2], tm_zone: tm_zone ? UTF8ToString(tm_zone) : "" }, pattern = UTF8ToString(format), EXPANSION_RULES_1 = { "%c": "%a %b %d %H:%M:%S %Y", "%D": "%m/%d/%y", "%F": "%Y-%m-%d", "%h": "%b", "%r": "%I:%M:%S %p", "%R": "%H:%M", "%T": "%H:%M:%S", "%x": "%m/%d/%y", "%X": "%H:%M:%S" }; for (var rule in EXPANSION_RULES_1) pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_1[rule]); var WEEKDAYS = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], MONTHS = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]; function leadingSomething(value, digits, character) { for (var str = "number" == typeof value ? value.toString() : value || ""; str.length < digits;)str = character[0] + str; return str } function leadingNulls(value, digits) { return leadingSomething(value, digits, "0") } function compareByDay(date1, date2) { function sgn(value) { return value < 0 ? -1 : value > 0 ? 1 : 0 } var compare; return 0 === (compare = sgn(date1.getFullYear() - date2.getFullYear())) && 0 === (compare = sgn(date1.getMonth() - date2.getMonth())) && (compare = sgn(date1.getDate() - date2.getDate())), compare } function getFirstWeekStartDate(janFourth) { switch (janFourth.getDay()) { case 0: return new Date(janFourth.getFullYear() - 1, 11, 29); case 1: return janFourth; case 2: return new Date(janFourth.getFullYear(), 0, 3); case 3: return new Date(janFourth.getFullYear(), 0, 2); case 4: return new Date(janFourth.getFullYear(), 0, 1); case 5: return new Date(janFourth.getFullYear() - 1, 11, 31); case 6: return new Date(janFourth.getFullYear() - 1, 11, 30) } } function getWeekBasedYear(date) { var thisDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday), janFourthThisYear = new Date(thisDate.getFullYear(), 0, 4), janFourthNextYear = new Date(thisDate.getFullYear() + 1, 0, 4), firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear), firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear); return compareByDay(firstWeekStartThisYear, thisDate) <= 0 ? compareByDay(firstWeekStartNextYear, thisDate) <= 0 ? thisDate.getFullYear() + 1 : thisDate.getFullYear() : thisDate.getFullYear() - 1 } var EXPANSION_RULES_2 = { "%a": function (date) { return WEEKDAYS[date.tm_wday].substring(0, 3) }, "%A": function (date) { return WEEKDAYS[date.tm_wday] }, "%b": function (date) { return MONTHS[date.tm_mon].substring(0, 3) }, "%B": function (date) { return MONTHS[date.tm_mon] }, "%C": function (date) { return leadingNulls((date.tm_year + 1900) / 100 | 0, 2) }, "%d": function (date) { return leadingNulls(date.tm_mday, 2) }, "%e": function (date) { return leadingSomething(date.tm_mday, 2, " ") }, "%g": function (date) { return getWeekBasedYear(date).toString().substring(2) }, "%G": function (date) { return getWeekBasedYear(date) }, "%H": function (date) { return leadingNulls(date.tm_hour, 2) }, "%I": function (date) { var twelveHour = date.tm_hour; return 0 == twelveHour ? twelveHour = 12 : twelveHour > 12 && (twelveHour -= 12), leadingNulls(twelveHour, 2) }, "%j": function (date) { return leadingNulls(date.tm_mday + __arraySum(__isLeapYear(date.tm_year + 1900) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, date.tm_mon - 1), 3) }, "%m": function (date) { return leadingNulls(date.tm_mon + 1, 2) }, "%M": function (date) { return leadingNulls(date.tm_min, 2) }, "%n": function () { return "\n" }, "%p": function (date) { return date.tm_hour >= 0 && date.tm_hour < 12 ? "AM" : "PM" }, "%S": function (date) { return leadingNulls(date.tm_sec, 2) }, "%t": function () { return "\t" }, "%u": function (date) { return new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0).getDay() || 7 }, "%U": function (date) { var janFirst = new Date(date.tm_year + 1900, 0, 1), firstSunday = 0 === janFirst.getDay() ? janFirst : __addDays(janFirst, 7 - janFirst.getDay()), endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstSunday, endDate) < 0) { var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31, days = 31 - firstSunday.getDate() + februaryFirstUntilEndMonth + endDate.getDate(); return leadingNulls(Math.ceil(days / 7), 2) } return 0 === compareByDay(firstSunday, janFirst) ? "01" : "00" }, "%V": function (date) { var daysDifference, janFourthThisYear = new Date(date.tm_year + 1900, 0, 4), janFourthNextYear = new Date(date.tm_year + 1901, 0, 4), firstWeekStartThisYear = getFirstWeekStartDate(janFourthThisYear), firstWeekStartNextYear = getFirstWeekStartDate(janFourthNextYear), endDate = __addDays(new Date(date.tm_year + 1900, 0, 1), date.tm_yday); return compareByDay(endDate, firstWeekStartThisYear) < 0 ? "53" : compareByDay(firstWeekStartNextYear, endDate) <= 0 ? "01" : (daysDifference = firstWeekStartThisYear.getFullYear() < date.tm_year + 1900 ? date.tm_yday + 32 - firstWeekStartThisYear.getDate() : date.tm_yday + 1 - firstWeekStartThisYear.getDate(), leadingNulls(Math.ceil(daysDifference / 7), 2)) }, "%w": function (date) { return new Date(date.tm_year + 1900, date.tm_mon + 1, date.tm_mday, 0, 0, 0, 0).getDay() }, "%W": function (date) { var janFirst = new Date(date.tm_year, 0, 1), firstMonday = 1 === janFirst.getDay() ? janFirst : __addDays(janFirst, 0 === janFirst.getDay() ? 1 : 7 - janFirst.getDay() + 1), endDate = new Date(date.tm_year + 1900, date.tm_mon, date.tm_mday); if (compareByDay(firstMonday, endDate) < 0) { var februaryFirstUntilEndMonth = __arraySum(__isLeapYear(endDate.getFullYear()) ? __MONTH_DAYS_LEAP : __MONTH_DAYS_REGULAR, endDate.getMonth() - 1) - 31, days = 31 - firstMonday.getDate() + februaryFirstUntilEndMonth + endDate.getDate(); return leadingNulls(Math.ceil(days / 7), 2) } return 0 === compareByDay(firstMonday, janFirst) ? "01" : "00" }, "%y": function (date) { return (date.tm_year + 1900).toString().substring(2) }, "%Y": function (date) { return date.tm_year + 1900 }, "%z": function (date) { var off = date.tm_gmtoff, ahead = off >= 0; return off = (off = Math.abs(off) / 60) / 60 * 100 + off % 60, (ahead ? "+" : "-") + String("0000" + off).slice(-4) }, "%Z": function (date) { return date.tm_zone }, "%%": function () { return "%" } }; for (var rule in EXPANSION_RULES_2) pattern.indexOf(rule) >= 0 && (pattern = pattern.replace(new RegExp(rule, "g"), EXPANSION_RULES_2[rule](date))); var bytes = intArrayFromString(pattern, !1); return bytes.length > maxsize ? 0 : (writeArrayToMemory(bytes, s), bytes.length - 1) } function _time(ptr) { var ret = Date.now() / 1e3 | 0; return ptr && (HEAP32[ptr >> 2] = ret), ret } function intArrayFromString(stringy, dontAddNull, length) { var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1, u8array = new Array(len), numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length); return dontAddNull && (u8array.length = numBytesWritten), u8array } FS.staticInit(), _emscripten_get_now = "undefined" != typeof dateNow ? dateNow : "object" == typeof performance && performance && "function" == typeof performance.now ? function () { return performance.now() } : Date.now; var asmGlobalArg = {}, asmLibraryArg = { d: abort, c: ___assert_fail, K: ___buildEnvironment, z: ___lock, y: ___setErrNo, G: ___syscall10, x: ___syscall140, ea: ___syscall142, da: ___syscall145, F: ___syscall146, E: ___syscall195, ca: ___syscall196, ba: ___syscall197, aa: ___syscall220, m: ___syscall221, $: ___syscall3, _: ___syscall33, Z: ___syscall340, Y: ___syscall38, X: ___syscall4, W: ___syscall40, D: ___syscall5, u: ___syscall54, t: ___syscall6, V: ___syscall75, U: ___syscall77, r: ___unlock, b: _abort, T: _clock, S: _clock_gettime, R: _emscripten_get_heap_size, Q: _emscripten_memcpy_big, P: _emscripten_resize_heap, q: _exit, O: _fabs, k: _getenv, N: _gettimeofday, M: _gmtime, w: _gmtime_r, l: _llvm_cos_f64, i: _llvm_exp2_f32, h: _llvm_exp2_f64, p: _llvm_log10_f32, g: _llvm_log10_f64, f: _llvm_log2_f32, L: _llvm_sin_f64, v: _llvm_stackrestore, C: _llvm_stacksave, e: _llvm_trunc_f32, J: _llvm_trunc_f64, B: _localtime, o: _localtime_r, I: _mktime, A: _nanosleep, j: _signal, n: _strftime, s: _time, H: abortOnCannotGrowMemory, a: DYNAMICTOP_PTR }, asm = Module.asm(asmGlobalArg, asmLibraryArg, buffer); Module.asm = asm; var ___emscripten_environ_constructor = Module.___emscripten_environ_constructor = function () { return Module.asm.fa.apply(null, arguments) }, ___errno_location = Module.___errno_location = function () { return Module.asm.ga.apply(null, arguments) }, __get_daylight = Module.__get_daylight = function () { return Module.asm.ha.apply(null, arguments) }, __get_timezone = Module.__get_timezone = function () { return Module.asm.ia.apply(null, arguments) }, __get_tzname = Module.__get_tzname = function () { return Module.asm.ja.apply(null, arguments) }, _fflush = Module._fflush = function () { return Module.asm.ka.apply(null, arguments) }, _free = Module._free = function () { return Module.asm.la.apply(null, arguments) }, _main = Module._main = function () { return Module.asm.ma.apply(null, arguments) }, _malloc = Module._malloc = function () { return Module.asm.na.apply(null, arguments) }, _memset = Module._memset = function () { return Module.asm.oa.apply(null, arguments) }, stackAlloc = Module.stackAlloc = function () { return Module.asm.qa.apply(null, arguments) }, stackRestore = Module.stackRestore = function () { return Module.asm.ra.apply(null, arguments) }, stackSave = Module.stackSave = function () { return Module.asm.sa.apply(null, arguments) }, dynCall_vi = Module.dynCall_vi = function () { return Module.asm.pa.apply(null, arguments) }; function ExitStatus(status) { this.name = "ExitStatus", this.message = "Program terminated with exit(" + status + ")", this.status = status } Module.asm = asm, ExitStatus.prototype = new Error, ExitStatus.prototype.constructor = ExitStatus; var calledMain = !1; function run(args) { function doRun() { Module.calledRun || (Module.calledRun = !0, ABORT || (ensureInitRuntime(), preMain(), Module.onRuntimeInitialized && Module.onRuntimeInitialized(), Module._main && shouldRunNow && Module.callMain(args), postRun())) } args = args || Module.arguments, runDependencies > 0 || (preRun(), runDependencies > 0 || Module.calledRun || (Module.setStatus ? (Module.setStatus("Running..."), setTimeout((function () { setTimeout((function () { Module.setStatus("") }), 1), doRun() }), 1)) : doRun())) } function exit(status, implicit) { implicit && Module.noExitRuntime && 0 === status || (Module.noExitRuntime || (ABORT = !0, EXITSTATUS = status, exitRuntime(), Module.onExit && Module.onExit(status)), Module.quit(status, new ExitStatus(status))) } function abort(what) { throw Module.onAbort && Module.onAbort(what), void 0 !== what ? (out(what), err(what), what = JSON.stringify(what)) : what = "", ABORT = !0, EXITSTATUS = 1, "abort(" + what + "). Build with -s ASSERTIONS=1 for more info." } if (dependenciesFulfilled = function runCaller() { Module.calledRun || run(), Module.calledRun || (dependenciesFulfilled = runCaller) }, Module.callMain = function callMain(args) { args = args || [], ensureInitRuntime(); var argc = args.length + 1, argv = stackAlloc(4 * (argc + 1)); HEAP32[argv >> 2] = allocateUTF8OnStack(Module.thisProgram); for (var i = 1; i < argc; i++)HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]); HEAP32[(argv >> 2) + argc] = 0; try { exit(Module._main(argc, argv, 0), !0) } catch (e) { if (e instanceof ExitStatus) return; if ("SimulateInfiniteLoop" == e) return void (Module.noExitRuntime = !0); var toLog = e; e && "object" == typeof e && e.stack && (toLog = [e, e.stack]), err("exception thrown: " + toLog), Module.quit(1, e) } finally { calledMain = !0 } }, Module.run = run, Module.abort = abort, Module.preInit) for ("function" == typeof Module.preInit && (Module.preInit = [Module.preInit]); Module.preInit.length > 0;)Module.preInit.pop()(); var shouldRunNow = !1; Module.noInitialRun && (shouldRunNow = !1), run(), self.addEventListener("message", event => { const data = event.data; if (data.file && data.isFile ? (Module.inputFileName = `/working/${data.file.name}`, FS.mount(WORKERFS, { files: [data.file] }, "/working")) : data.file && !data.isFile && (Module.inputFileName = "/working/input.mp3", FS.mount(WORKERFS, { blobs: [{ name: "input.mp3", data: data.file }] }, "/working")), "decodeFile" == data.type) Module.progressScaleFactor = Module.progressScaleFactor - data.progressOffset, Module.progressOffset = data.progressOffset, Module.bitrate = data.bitrate, Module.decodeFile(Module.inputFileName, data.waveformParams, data.copyCodec); else if ("cut" == data.type) { const cutParams = data.cutParams; Module.bitrate = cutParams.bitrate, Module.copyCoverCodec = cutParams.copyCoverCodec, Module.cutFile(Module.inputFileName, cutParams) } else if ("checkIfAudioAndMp3" == data.type) try { Module.checkIfAudioAndMP3(Module.inputFileName) } catch (err) { self.postMessage({ type: "permissionError" }) } else "getFileParts" == data.type ? (Module.partExt = data.partExt.replace("m4a", "adts"), Module.getFileParts(Module.inputFileName)) : self.postMessage({ type: "unsupported" }) });